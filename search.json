[
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "Installing ggsql",
    "section": "",
    "text": "ggsql is very much still a work in progress and the installation process reflects this. Eventually we will have proper installers but for now please follow this process if you wish to play around with it:\n\nClone the repository:\ngit clone https://github.com/georgestagg/ggsql\ncd ggsql\nInstall tree-sitter CLI:\nnpm install -g tree-sitter-cli\nBuild the project:\ncd tree-sitter-ggsql && tree-sitter generate && cd ..\ncargo build\nInstall the Jupyter kernel:\ncargo run --package ggsql-jupyter -- --install"
  },
  {
    "objectID": "syntax/clause/visualise.html",
    "href": "syntax/clause/visualise.html",
    "title": "Initialise a visualisation with VISUALISE",
    "section": "",
    "text": "The VISUALISE (or VISUALIZE) clause marks the beginning of a ggsql visualisation declaration. As such it demarcates where the regular query ends and the visualisation query starts. Everything that comes before the VISUALISE clause is considered a standard SQL query that is sent to the backend. Any CTEs defined therein will be available to the ggsql query, and if it ends with a SELECT query this will automatically be added as the global data for the plot."
  },
  {
    "objectID": "syntax/clause/visualise.html#clause-syntax",
    "href": "syntax/clause/visualise.html#clause-syntax",
    "title": "Initialise a visualisation with VISUALISE",
    "section": "Clause syntax",
    "text": "Clause syntax\nThe VISUALISE clause is quite simple and doesn‚Äôt take any additional required parameters. You can, however, use it to define global mappings and a global data source (if the earlier query didn‚Äôt end in a SELECT).\nVISUALISE &lt;mapping&gt;, ... FROM &lt;data-source&gt;\nFollowing VISUALISE you can provide a series of global mappings. These will be inherited by the layers created with the DRAW clause but can be overwritten by them. Mappings define how data from the dataset are related to visual aesthetics or statistical properties. Multiple mappings can be provided by separating them with a comma. Mapped aesthetics are always scaled by their respective scale. This means that if you map the value ‚Äòred‚Äô to fill, then fill will not take the color red, but whatever the scale decides should represent the string ‚Äòred‚Äô.\nVISUALISE may have a FROM clause that defines the source of the global data. If present it overwrites the terminal SELECT clause in the previous query as the global data. Global data is used by layers that do not specify their own data source with MAPPING ... FROM &lt;data-source&gt;.\nThe mapping can take one of three forms and all three can be mixed:\n\n&lt;data&gt; AS &lt;aesthetic/property&gt; (explicit mapping)\n&lt;data&gt; (implicit mapping)\n* (wildcard mapping)\n\ndata can be either:\n\nColumn name: If you provide the name of a column in the data then the values in that column are mapped to the aesthetic or property. If the name of the column is the same as the aesthetic or property you can provide it without the following AS &lt;aesthetic/property&gt; (implicit mapping).\nConstant: If you provide a constant like a string, number, or boolean then this value is repeated for every record in the data and mapped to the given aesthetic or property. When mapping a constant you must use the explicit form since the aesthetic/property cannot be derived.\n\nIf an asterisk is given (wildcard mapping) it indicate that every column in the layer data with a name matching a supported aesthetic or property are implicitly mapped to said aesthetic or property. If the aesthetic or property has been mapped elsewhere then that gains precedence (i.e.¬†if writing VISUALISE *, revenue AS y then y will take on the data in the revenue column even if a y column exist in the data)\nAn aesthetic is a visual characteristic of what you are rendering. Different aesthetics are available depending on the layer type since e.g.¬†linetype is not relevant for points and shape are not relevant for lines.\nA property is a value used by the statistical transformation done by the layer, e.g.¬†the weight property in the histogram layer that allows weighted histogram calculation.\n\nMapped aesthetics are always scaled by their respective scale, whereas properties are not (there are no scales for properties).\n\nLayers only inherit the aesthetics and properties they support from the global mapping. The documentation for each layer type provides an overview of the aesthetics and properties available for them.\nWhen specifying a global data source with FROM &lt;data-source&gt; the data-source can take one of two different forms:\n\nTable/CTE: If providing an unquoted identifier it is assumed that the data is available in the backend, either as a CTE defined in the pre-query, or as a proper table in the database.\nFilepath: If a string is provided (single quoted), it is assumed to point to a file that can be read directly by the backend."
  },
  {
    "objectID": "syntax/layer/point.html",
    "href": "syntax/layer/point.html",
    "title": "Point layer",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nThe point geom is used to create scatterplots. The scatterplot is most useful for displaying the relationship between two continuous variables. A bubblechart is a scatterplot with a third variable mapped to the size of points."
  },
  {
    "objectID": "syntax/layer/point.html#aesthetics",
    "href": "syntax/layer/point.html#aesthetics",
    "title": "Point layer",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the point layer.\n\nRequired\n\nx: Position along the x-axis\ny: Position along the y-axis\n\n\n\nOptional\n\nsize: The size of each point\ncolour: The default colour of the each point\nstroke: The colour of the stroke around each point (if any). Overrides colour\nfill: The fill colour of each point (if any). Overrides colour\nopacity: The opacity of the point\nshape: The shape used to draw the point"
  },
  {
    "objectID": "syntax/layer/point.html#settings",
    "href": "syntax/layer/point.html#settings",
    "title": "Point layer",
    "section": "Settings",
    "text": "Settings\nThe point layer has no additional settings"
  },
  {
    "objectID": "syntax/layer/point.html#data-transformation",
    "href": "syntax/layer/point.html#data-transformation",
    "title": "Point layer",
    "section": "Data transformation",
    "text": "Data transformation\nThe point layer does not transform its data but passes it through unchanged"
  },
  {
    "objectID": "syntax/layer/point.html#examples",
    "href": "syntax/layer/point.html#examples",
    "title": "Point layer",
    "section": "Examples",
    "text": "Examples\nCreate a classic scatterplot\nVISUALISE FROM penguins\nDRAW point\n    MAPPING bill_len AS x, bill_dep AS y, species AS fill\n    SETTING size =&gt; 30\nMap to size to create a bubble chart\nVISUALISE FROM penguins\nDRAW point\n    MAPPING bill_len AS x, bill_dep AS y, body_mass AS size\nUse filter to only plot a subset of the data\nVISUALISE FROM penguins\nDRAW point\n    MAPPING bill_len AS x, bill_dep AS y, species AS fill\n    SETTING size =&gt; 30\n    FILTER sex = 'female'"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ggsql - SQL Visualization Grammar",
    "section": "",
    "text": "A SQL extension for declarative data visualization based on the Grammar of Graphics.\nggsql allows you to write queries that combine SQL data retrieval with visualization specifications in a single, composable syntax."
  },
  {
    "objectID": "index.html#example",
    "href": "index.html#example",
    "title": "ggsql - SQL Visualization Grammar",
    "section": "Example",
    "text": "Example\nSELECT date, revenue, region\nFROM sales\nWHERE year = 2024\nVISUALISE date AS x, revenue AS y, region AS color\nDRAW line\nLABEL title =&gt; 'Sales by Region'\nTHEME minimal"
  },
  {
    "objectID": "index.html#project-status",
    "href": "index.html#project-status",
    "title": "ggsql - SQL Visualization Grammar",
    "section": "Project Status",
    "text": "Project Status\n‚ú® Active Development - Core functionality is working with ongoing feature additions and refinements.\nCompleted:\n\n‚úÖ Complete tree-sitter grammar with SQL + VISUALISE parsing\n‚úÖ Full AST type system with validation\n‚úÖ DuckDB reader with comprehensive type handling\n‚úÖ Vega-Lite writer with multi-layer support\n‚úÖ CLI tool (ggsql) with parse, exec, and validate commands\n‚úÖ REST API server (ggsql-rest) with CORS support\n‚úÖ Jupyter kernel (ggsql-jupyter) with inline Vega-Lite visualizations\n‚úÖ knitr-engine (ggsql-jupyter) with inline Vega-Lite visualizations\n‚úÖ VS Code extension (ggsql-vscode) with syntax highlighting for .ggsql files\n\nPlanned:\n\nüìã Additional readers\nüìã Additional writers\nüìã More geom types and statistical transformations\nüìã Enhanced theme system"
  },
  {
    "objectID": "index.html#architecture",
    "href": "index.html#architecture",
    "title": "ggsql - SQL Visualization Grammar",
    "section": "Architecture",
    "text": "Architecture\nggsql splits queries at the VISUALISE boundary:\n\nSQL portion ‚Üí passed to pluggable readers (DuckDB, PostgreSQL, CSV, etc.)\nVISUALISE portion ‚Üí parsed and compiled into visualization specifications\nOutput ‚Üí rendered via pluggable writers (ggplot2, PNG, Vega-Lite, etc.)"
  },
  {
    "objectID": "index.html#grammar-specification",
    "href": "index.html#grammar-specification",
    "title": "ggsql - SQL Visualization Grammar",
    "section": "Grammar Specification",
    "text": "Grammar Specification\nSee CLAUDE.md for the in-progress ggsql grammar specification, including:\n\nSyntax reference\nAST structure\nImplementation phases and architecture\nDesign principles and philosophy\n\nKey grammar elements:\n\nVISUALISE [mappings] [FROM source] - Entry point with global aesthetic mappings\nDRAW &lt;geom&gt; [MAPPING] [SETTING] [FILTER] - Define geometric layers (point, line, bar, etc.)\nSCALE &lt;aesthetic&gt; SETTING - Configure data-to-visual mappings\nFACET - Create small multiples (WRAP for flowing layout, BY for grid)\nCOORD - Coordinate transformations (cartesian, flip, polar)\nLABEL, THEME, GUIDE - Styling and annotation"
  },
  {
    "objectID": "index.html#jupyter-kernel",
    "href": "index.html#jupyter-kernel",
    "title": "ggsql - SQL Visualization Grammar",
    "section": "Jupyter Kernel",
    "text": "Jupyter Kernel\nThe ggsql-jupyter package provides a Jupyter kernel for interactive ggsql queries with inline Vega-Lite visualizations.\n\nInstallation\ncargo build --release --package ggsql-jupyter\n./target/release/ggsql-jupyter --install\n\n\nUsage\nAfter installation, create a new notebook with the ‚Äúggsql‚Äù kernel or use %kernel ggsql in an existing notebook.\n-- Create data\nCREATE TABLE sales AS\nSELECT * FROM (VALUES\n    ('2024-01-01'::DATE, 100, 'North'),\n    ('2024-01-02'::DATE, 120, 'South')\n) AS t(date, revenue, region)\n\n-- Visualize with ggsql using global mapping\nSELECT * FROM sales\nVISUALISE date AS x, revenue AS y, region AS color\nDRAW line\nSCALE x SETTING type =&gt; 'date'\nLABEL title =&gt; 'Sales Trends'\nThe kernel maintains a persistent DuckDB session across cells, so you can create tables in one cell and query them in another.\n\n\nQuarto\nA Quarto example can be found in ggsql-jupyter/tests/quarto/doc.qmd."
  },
  {
    "objectID": "index.html#vs-code-extension",
    "href": "index.html#vs-code-extension",
    "title": "ggsql - SQL Visualization Grammar",
    "section": "VS Code Extension",
    "text": "VS Code Extension\nThe ggsql-vscode extension provides syntax highlighting for ggsql files in Visual Studio Code.\n\nInstallation\n# Package the extension\ncd ggsql-vscode\nnpm install -g @vscode/vsce\nvsce package\n\n# Install the VSIX file\ncode --install-extension ggsql-0.1.0.vsix\n\n\nFeatures\n\nSyntax highlighting for ggsql keywords, geoms, aesthetics, and SQL\nFile association for .ggsql, .ggsql.sql, and .gsql extensions\nBracket matching and auto-closing for parentheses and brackets\nComment support for -- single-line and /* */ multi-line comments\n\nThe extension uses a TextMate grammar that highlights:\n\nSQL keywords (SELECT, FROM, WHERE, JOIN, etc.)\nggsql clauses (VISUALISE, DRAW, SCALE, COORD, FACET, etc.)\nGeometric objects (point, line, bar, area, etc.)\nAesthetics (x, y, color, size, shape, etc.)\nScale types (linear, log10, date, viridis, etc.)"
  },
  {
    "objectID": "index.html#cli",
    "href": "index.html#cli",
    "title": "ggsql - SQL Visualization Grammar",
    "section": "CLI",
    "text": "CLI\n\nInstallation\ncargo install --path src"
  },
  {
    "objectID": "syntax/index.html",
    "href": "syntax/index.html",
    "title": "Syntax",
    "section": "",
    "text": "ggsql augments the standard SQL syntax with a number of new clauses to describe a visualisation:\n\nVISUALISE initiates the visualisation part of the query\nDRAW adds a new layer to the visualisation\nSCALE specify how an aesthetic should be scaled\nFACET describes how data should be split into small multiples\nPROJECT is used for selecting the coordinate system to use\nLABEL is used to manually add titles to the plot or the various axes and legends"
  },
  {
    "objectID": "syntax/index.html#main-clauses",
    "href": "syntax/index.html#main-clauses",
    "title": "Syntax",
    "section": "",
    "text": "ggsql augments the standard SQL syntax with a number of new clauses to describe a visualisation:\n\nVISUALISE initiates the visualisation part of the query\nDRAW adds a new layer to the visualisation\nSCALE specify how an aesthetic should be scaled\nFACET describes how data should be split into small multiples\nPROJECT is used for selecting the coordinate system to use\nLABEL is used to manually add titles to the plot or the various axes and legends"
  },
  {
    "objectID": "syntax/index.html#layers",
    "href": "syntax/index.html#layers",
    "title": "Syntax",
    "section": "Layers",
    "text": "Layers\nThere are many different layers to choose from when visualising your data. Some are straightforward translations of your data into visual marks such as a point layer, while others perform more or less complicated calculations like e.g.¬†the histogram layer. A layer is selected by providing the layer name after the DRAW clause\n\npoint is used to create a scatterplot layer\nline is used to produce lineplots with the data sorted along the x axis\npath is like line above but does not sort the data but plot it according to its own order\nbar creates a bar chart, optionally calculating y from the number of records in each bar\nhistogram bins the data along the x axis and produces a bar for each bin showing the number of records in it"
  },
  {
    "objectID": "syntax/index.html#scales",
    "href": "syntax/index.html#scales",
    "title": "Syntax",
    "section": "Scales",
    "text": "Scales"
  },
  {
    "objectID": "syntax/index.html#coordinate-systems",
    "href": "syntax/index.html#coordinate-systems",
    "title": "Syntax",
    "section": "Coordinate systems",
    "text": "Coordinate systems"
  },
  {
    "objectID": "syntax/clause/draw.html",
    "href": "syntax/clause/draw.html",
    "title": "Create layers with DRAW",
    "section": "",
    "text": "DRAW is perhaps the most important clause in ggsql as it defines a layer in your visualisation. A layer is a single instance of a visual representation of a dataset. A visualisation can contain multiple layers, either showing the same dataset in different ways or showing different data in each. Layers are drawn in the order they are defined, so that layers defined first will be behind layers defined last."
  },
  {
    "objectID": "syntax/clause/draw.html#clause-syntax",
    "href": "syntax/clause/draw.html#clause-syntax",
    "title": "Create layers with DRAW",
    "section": "Clause syntax",
    "text": "Clause syntax\nThe DRAW clause takes a number of subclauses, all of them optional if the VISUALISE clause provides a global mapping and data source.\nDRAW &lt;layer-type&gt;\n    MAPPING &lt;mapping&gt;, ... FROM &lt;data-source&gt;\n    REMAPPING &lt;mapping&gt;, ...\n    SETTING &lt;parameter/aesthetic&gt; =&gt; &lt;value&gt;, ...\n    FILTER &lt;condition&gt;\n    PARTITION BY &lt;column&gt;, ...\n    ORDER BY &lt;column&gt;, ...\nThe only required part is the layer type immediately following the DRAW clause, which specifies the type of layer to draw, e.g.¬†point or histogram. It defines how the remaining settings are interpreted. The main syntax page has a list of all available layer types\n\nMAPPING\nMAPPING &lt;mapping&gt;, ... FROM &lt;data-source&gt;\nThe MAPPINGS clause define how data from the dataset are related to visual aesthetics or statistical properties. Multiple mappings can be provided by separating them with a comma. Mapped aesthetics are always scaled by their respective scale. This means that if you map the value ‚Äòred‚Äô to fill, then fill will not take the color red, but whatever the scale decides should represent the string ‚Äòred‚Äô. Layer mappings are merged with the global mapping from the VISUALISE clause with the one in the layer taking precedence. This means that it is not necessary to provide any mappings in the DRAW clause if sufficient global mappings are provided.\nMAPPING may have a FROM clause that defines the source of the data. If this is missing the global data source from VISUALISE is used.\nThe mapping can take one of three forms and all three can be mixed in the same MAPPING clause:\n\n&lt;data&gt; AS &lt;aesthetic/property&gt; (explicit mapping)\n&lt;data&gt; (implicit mapping)\n* (wildcard mapping)\n\ndata can be either:\n\nColumn name: If you provide the name of a column in the layer data (or global data in the absence of layer data) then the values in that column are mapped to the aesthetic or property. If the name of the column is the same as the aesthetic or property you can provide it without the following AS &lt;aesthetic/property&gt; (implicit mapping).\nConstant: If you provide a constant like a string, number, or boolean then this value is repeated for every record in the data and mapped to the given aesthetic or property. When mapping a constant you must use the explicit form since the aesthetic/property cannot be derived.\n\nIf an asterisk is given (wildcard mapping) it indicate that every column in the layer data with a name matching a supported aesthetic or property are implicitly mapped to said aesthetic or property. If the aesthetic or property has been mapped elsewhere then that gains precedence (i.e.¬†if writing MAPPING *, revenue AS y then y will take on the data in the revenue column even if a y column exist in the data)\nAn aesthetic is a visual characteristic of what you are rendering. Different aesthetics are available depending on the layer type since e.g.¬†linetype is not relevant for points and shape are not relevant for lines.\nA property is a value used by the statistical transformation done by the layer, e.g.¬†the weight property in the histogram layer that allows weighted histogram calculation.\n\nMapped aesthetics are always scaled by their respective scale, whereas properties are not (there are no scales for properties).\n\nThe documentation for each layer type provides an overview of the aesthetics and properties available for them.\nA layer may use a data source different than the global data by appending a FROM &lt;data-source&gt; to the mapping. The data source can be either:\n\nTable/CTE: If providing an unquoted identifier it is assumed that the data is available in the backend, either as a CTE defined in the pre-query, or as a proper table in the database.\nFilepath: If a string is provided (single quoted), it is assumed to point to a file that can be read directly by the backend.\n\n\n\nREMAPPING\nREMAPPING &lt;mapping&gt;, ...\nSome layer types like histogram runs the data through a statistical transformation in order to arrive at the data that needs to be displayed (e.g.¬†count per bin). During this, one or more columns are added to the data and you can access these in the REMAPPING clause. Layers that perform statistical transformations always have a default remapping (e.g.¬†count AS y in histogram) so it never required to specify a remapping, but you can do so, either to change the default (e.g.¬†density AS yto access the calculated density instead of count), or to use the calculated property for another aesthetic (e.g.¬†count AS fill to also shade the bars according to their height).\nRemappings have to be explicit since the property name never coincide with an aesthetic. Further, remappings must always map to a visual aesthetic since the statistical properties have already been consumed.\n\n\nSETTING\nSETTING &lt;parameter/aesthetic&gt; =&gt; &lt;value&gt;, ...\nThe SETTING clause can be used for to different things:\n\nSetting parameters: Some layers take additional arguments that control how they behave. Often, but not always, these modify the statistical transformation in some way. An example would be the binwidth parameter in histogram which controls the width of each bin during histogram calculation. This is not a statistical property since it is not related to each record, but to the calculation as a whole.\nSetting aesthetics: If you wish to set a specific aesthetic to a literal value, e.g.¬†‚Äòred‚Äô (as in the color red) then you can do so in the SETTING clause. Aesthetics that are set will not go through a scale but will use the provided value as-is. You cannot set an aesthetic to a column, only to a scalar literal value.\n\n\n\nFILTER\nFILTER &lt;condition&gt;\nYou may not want to use all data provided from the data source in the layer. You can limit the data to plot with the FILTER clause. The content of condition is used directly in a WHERE clause when querying the backend for the layer data, so whatever type of expression you database backend supports there will work.\n\n\nPARTITION BY\nPARTITION BY &lt;column&gt;, ...\nDuring drawing the records in the layer data are grouped by all the discrete data that has been mapped. This grouping is not relevant to all layer types but critical for some, e.g.¬†line layers where the grouping defines which records are connected with a line.\nOften the implicit grouping from the aesthetic mapping is enough, e.g.¬†mapping a discrete value to colour will create one line per colour, but sometimes you need a grouping not reflected in the aesthetic mapping. In that case you can use the PARTITION BY clause to define data columns used for grouping in addition to the ones from the mapping.\n\n\nORDER BY\nORDER BY &lt;column&gt;, ...\nFor some layers the order of records in the data is important, e.g.¬†the path layer which connect records in the order they are provided. Since databases often doesn‚Äôt guarantee a specific order of the data, the ORDER BY clause can be used to enforce such and order. Even for layers where the order doesn‚Äôt immediately seem to matter it may have an effect, e.g.¬†an overplottet scatterplot where the records in the end of the data are plottet on top of the one in the start."
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Examples",
    "section": "",
    "text": "This document demonstrates various ggsql features with runnable examples using CSV files."
  },
  {
    "objectID": "examples.html#basic-visualizations",
    "href": "examples.html#basic-visualizations",
    "title": "Examples",
    "section": "Basic Visualizations",
    "text": "Basic Visualizations\n\nSimple Scatter Plot\n\nSELECT x, y FROM 'data.csv'\nVISUALISE x, y\nDRAW point\n\n\n\n\n\n\n\nLine Chart with Date Scale\n\nSELECT sale_date, revenue FROM 'sales.csv'\nWHERE category = 'Electronics'\nVISUALISE sale_date AS x, revenue AS y\nDRAW line\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Electronics Revenue Over Time', \n    x =&gt; 'Date', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nBar Chart by Category\n\nSELECT category, SUM(revenue) as total\nFROM 'sales.csv'\nGROUP BY category\nVISUALISE category AS x, total AS y, category AS fill\nDRAW bar\nLABEL \n    title =&gt; 'Total Revenue by Category', \n    x =&gt; 'Category', \n    y =&gt; 'Total Revenue ($)'\n\n\n\n\n\n\n\nLine chart with multiple lines with same aesthetics\n\nSELECT * FROM 'sales.csv'\nVISUALISE sale_date AS x, revenue AS y\nDRAW line\n    PARTITION BY category"
  },
  {
    "objectID": "examples.html#multiple-layers",
    "href": "examples.html#multiple-layers",
    "title": "Examples",
    "section": "Multiple Layers",
    "text": "Multiple Layers\n\nLine with Points\n\nSELECT date, value FROM 'timeseries.csv'\nVISUALISE date AS x, value AS y\nDRAW line \n    SETTING  color =&gt; 'blue'\nDRAW point \n    SETTING size =&gt; 30, color =&gt; 'red'\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Time Series with Points', \n    x =&gt; 'Date', \n    y =&gt; 'Value'\n\n\n\n\n\n\n\nColored Lines by Category\n\nSELECT date, value, category FROM 'metrics.csv'\nVISUALISE date AS x, value AS y, category AS color\nDRAW line\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Metrics by Category', \n    x =&gt; 'Date', \n    y =&gt; 'Value'"
  },
  {
    "objectID": "examples.html#faceting",
    "href": "examples.html#faceting",
    "title": "Examples",
    "section": "Faceting",
    "text": "Faceting\n\nFacet Wrap by Region\n\nSELECT sale_date, revenue, region FROM 'sales.csv'\nWHERE category = 'Electronics'\nVISUALISE sale_date AS x, revenue AS y\nDRAW line\nSCALE x SETTING type =&gt; 'date'\nFACET WRAP region\nLABEL \n    title =&gt; 'Electronics Sales by Region', \n    x =&gt; 'Date', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nFacet Grid\n\nSELECT\n    DATE_TRUNC('month', sale_date) as month,\n    region,\n    category,\n    SUM(revenue) as total_revenue,\n    SUM(quantity) * 100 as total_quantity_scaled\nFROM 'sales.csv'\nGROUP BY DATE_TRUNC('month', sale_date), region, category\nVISUALISE month AS x\nDRAW line \n    MAPPING total_revenue AS y\n    SETTING color =&gt; 'steelblue'\nDRAW point \n    MAPPING total_revenue AS y\n    SETTING size =&gt; 30, color =&gt; 'darkblue'\nDRAW line \n    MAPPING total_quantity_scaled AS y\n    SETTING color =&gt; 'coral'\nDRAW point \n    MAPPING total_quantity_scaled AS y\n    SETTING size =&gt; 30, color =&gt; 'orangered'\nSCALE x SETTING type =&gt; 'date'\nFACET region BY category\nLABEL \n    title =&gt; 'Monthly Revenue and Quantity by Region and Category', \n    x =&gt; 'Month', \n    y =&gt; 'Value'"
  },
  {
    "objectID": "examples.html#coordinate-transformations",
    "href": "examples.html#coordinate-transformations",
    "title": "Examples",
    "section": "Coordinate Transformations",
    "text": "Coordinate Transformations\n\nFlipped Coordinates (Horizontal Bar Chart)\n\nSELECT region, SUM(revenue) as total\nFROM 'sales.csv'\nGROUP BY region\nORDER BY total DESC\nVISUALISE region AS x, total AS y, region AS fill\nDRAW bar\nCOORD flip\nLABEL \n    title =&gt; 'Total Revenue by Region', \n    x =&gt; 'Region', \n    y =&gt; 'Total Revenue ($)'\n\n\n\n\n\n\n\nCartesian with Axis Limits\n\nSELECT x, y FROM 'data.csv'\nVISUALISE x, y\nDRAW point \n    SETTING size =&gt; 4, color =&gt; 'blue'\nCOORD cartesian \n    SETTING xlim =&gt; [0, 60], ylim =&gt; [0, 70]\nLABEL \n    title =&gt; 'Scatter Plot with Custom Axis Limits', \n    x =&gt; 'X', \n    y =&gt; 'Y'\n\n\n\n\n\n\n\nPie Chart with Polar Coordinates\n\nSELECT category, SUM(revenue) as total\nFROM 'sales.csv'\nGROUP BY category\nVISUALISE total AS y, category AS fill\nDRAW bar\nCOORD polar\nLABEL \n    title =&gt; 'Revenue Distribution by Category'"
  },
  {
    "objectID": "examples.html#constant-mappings",
    "href": "examples.html#constant-mappings",
    "title": "Examples",
    "section": "Constant Mappings",
    "text": "Constant Mappings\nConstants can be used in both the VISUALISE clause (global) and MAPPING clauses (per-layer) to set fixed aesthetic values.\n\nDifferent Constants Per Layer\nEach layer can have its own constant value, creating a legend showing all values:\n\nWITH monthly AS (\n    SELECT\n        DATE_TRUNC('month', sale_date) as month,\n        category,\n        SUM(revenue) as revenue\n    FROM 'sales.csv'\n    GROUP BY DATE_TRUNC('month', sale_date), category\n)\nVISUALISE month AS x, revenue AS y\nDRAW line \n    MAPPING 'Electronics' AS color FROM monthly \n    FILTER category = 'Electronics'\nDRAW line \n    MAPPING 'Clothing' AS color FROM monthly \n    FILTER category = 'Clothing'\nDRAW line \n    MAPPING 'Furniture' AS color FROM monthly \n    FILTER category = 'Furniture'\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Revenue by Category (Constant Colors)', \n    x =&gt; 'Month', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nMixed Constants and Columns\nWhen mixing constant and column mappings for the same aesthetic, the axis/legend label uses the first non-constant column name:\n\nSELECT date, value, category FROM 'metrics.csv'\nVISUALISE date AS x\nDRAW line \n    MAPPING value AS y, category AS color\nDRAW point \n    MAPPING 120 AS y \n    SETTING size =&gt; 20, color =&gt; 'blue'\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Metrics with Threshold Line', \n    x =&gt; 'Date'\n\n\n\n\n\n\n\nNumeric Constants\nNumbers work as constants too:\n\nSELECT x, y FROM 'data.csv'\nVISUALISE x, y\nDRAW point \n    SETTING color =&gt; 'blue', size =&gt; 100\nDRAW point \n    SETTING color =&gt; 'red', size =&gt; 50 \n    FILTER y &gt; 50\nLABEL \n    title =&gt; 'Scatter Plot with Constant Sizes'"
  },
  {
    "objectID": "examples.html#layer-filtering",
    "href": "examples.html#layer-filtering",
    "title": "Examples",
    "section": "Layer filtering",
    "text": "Layer filtering\n\nFilter one layer\n\nSELECT date, value FROM 'timeseries.csv'\nVISUALISE date AS x, value AS y\nDRAW line \n    SETTING color =&gt; 'blue'\nDRAW point \n    SETTING color =&gt; 'red', size =&gt; 30 \n    FILTER value &lt; 130\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Time Series with Points', \n    x =&gt; 'Date', \n    y =&gt; 'Value'"
  },
  {
    "objectID": "examples.html#layer-ordering",
    "href": "examples.html#layer-ordering",
    "title": "Examples",
    "section": "Layer ordering",
    "text": "Layer ordering\n\nORDER BY in a layer\nUse ORDER BY to ensure data is sorted correctly within a layer. This is especially important for line charts where the order of points affects the visual path:\n\nWITH unordered_data AS (\n    SELECT * FROM (VALUES\n        (150.0, '2023-03-01'::DATE),\n        (100.0, '2023-01-01'::DATE),\n        (120.0, '2023-05-01'::DATE),\n        (200.0, '2023-02-01'::DATE),\n        (180.0, '2023-04-01'::DATE)\n    ) AS t(value, date)\n)\nVISUALISE\nDRAW path \n    MAPPING date AS x, value AS y FROM unordered_data \n    ORDER BY date\nDRAW point \n    MAPPING date AS x, value AS y FROM unordered_data \n    SETTING size =&gt; 40, color =&gt; 'red'\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Line Chart with ORDER BY', \n    x =&gt; 'Date', \n    y =&gt; 'Value'\n\n\n\n\n\n\n\nCombining FILTER and ORDER BY\nThe ORDER BY clause can be combined with FILTER and other layer options:\n\nSELECT date, value, category FROM 'metrics.csv'\nVISUALISE\nDRAW path \n    MAPPING date AS x, value AS y, category AS color \n    FILTER category != 'Support' \n    ORDER BY value\nDRAW point \n    MAPPING date AS x, value AS y, category AS color \n    SETTING size =&gt; 20 \n    FILTER category != 'Support' \nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Sales and Marketing Metrics (Ordered)', \n    x =&gt; 'Date', \n    y =&gt; 'Value'"
  },
  {
    "objectID": "examples.html#common-table-expressions-ctes",
    "href": "examples.html#common-table-expressions-ctes",
    "title": "Examples",
    "section": "Common Table Expressions (CTEs)",
    "text": "Common Table Expressions (CTEs)\n\nSimple CTE with VISUALISE FROM\n\nWITH monthly_sales AS (\n    SELECT\n        DATE_TRUNC('month', sale_date) as month,\n        SUM(revenue) as total_revenue\n    FROM 'sales.csv'\n    GROUP BY DATE_TRUNC('month', sale_date)\n)\nVISUALISE month AS x, total_revenue AS y FROM monthly_sales\nDRAW line\nDRAW point\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Monthly Revenue Trends', \n    x =&gt; 'Month', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nMultiple CTEs\n\nWITH daily_sales AS (\n    SELECT sale_date, region, SUM(revenue) as revenue\n    FROM 'sales.csv'\n    GROUP BY sale_date, region\n),\nregional_totals AS (\n    SELECT region, SUM(revenue) as total\n    FROM daily_sales\n    GROUP BY region\n)\nVISUALISE region AS x, total AS y, region AS fill FROM regional_totals\nDRAW bar\nCOORD flip\nLABEL \n    title =&gt; 'Total Revenue by Region', \n    x =&gt; 'Region', \n    y =&gt; 'Total Revenue ($)'"
  },
  {
    "objectID": "examples.html#layer-specific-data-sources-mapping-from",
    "href": "examples.html#layer-specific-data-sources-mapping-from",
    "title": "Examples",
    "section": "Layer-Specific Data Sources (MAPPING FROM)",
    "text": "Layer-Specific Data Sources (MAPPING FROM)\nLayers can pull data from different sources using MAPPING FROM. This enables overlaying data from different CTEs or tables.\n\nComparing Actuals vs Targets\nEach layer can reference a different CTE using MAPPING ... FROM cte_name:\n\nWITH actuals AS (\n    SELECT\n        DATE_TRUNC('month', sale_date) as month,\n        SUM(revenue) as value\n    FROM 'sales.csv'\n    GROUP BY DATE_TRUNC('month', sale_date)\n),\ntargets AS (\n    SELECT * FROM (VALUES\n        ('2023-01-01'::DATE, 5000.0),\n        ('2023-02-01'::DATE, 5500.0),\n        ('2023-03-01'::DATE, 6000.0),\n        ('2023-04-01'::DATE, 6500.0),\n        ('2023-05-01'::DATE, 7000.0),\n        ('2023-06-01'::DATE, 7500.0),\n        ('2023-07-01'::DATE, 8000.0),\n        ('2023-08-01'::DATE, 8500.0),\n        ('2023-09-01'::DATE, 9000.0),\n        ('2023-10-01'::DATE, 9500.0),\n        ('2023-11-01'::DATE, 10000.0),\n        ('2023-12-01'::DATE, 10500.0)\n    ) AS t(month, value)\n)\nVISUALISE\nDRAW line \n    MAPPING month AS x, value AS y, 'Actual' AS color FROM actuals\nDRAW point \n    MAPPING month AS x, value AS y, 'Actual' AS color FROM actuals \n    SETTING size =&gt; 30\nDRAW line \n    MAPPING month AS x, value AS y, 'Target' AS color FROM targets\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Revenue: Actual vs Target', \n    x =&gt; 'Month', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nCTE Chain: Raw ‚Üí Filtered ‚Üí Aggregated\nCTEs can reference other CTEs, creating a data transformation pipeline:\n\nWITH raw_data AS (\n    SELECT sale_date, revenue, category, region\n    FROM 'sales.csv'\n),\nelectronics_only AS (\n    SELECT * FROM raw_data\n    WHERE category = 'Electronics'\n),\nmonthly_electronics AS (\n    SELECT\n        DATE_TRUNC('month', sale_date) as month,\n        region,\n        SUM(revenue) as total\n    FROM electronics_only\n    GROUP BY DATE_TRUNC('month', sale_date), region\n)\nVISUALISE month AS x, total AS y, region AS color FROM monthly_electronics\nDRAW line\nDRAW point\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Electronics Revenue by Region (CTE Chain)', \n    x =&gt; 'Month', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nLayer FROM with FILTER\nCombine FROM with FILTER to get filtered subsets from a CTE:\n\nWITH all_sales AS (\n    SELECT\n        DATE_TRUNC('month', sale_date) as month,\n        category,\n        SUM(revenue) as revenue\n    FROM 'sales.csv'\n    GROUP BY DATE_TRUNC('month', sale_date), category\n)\nVISUALISE\nDRAW line \n    MAPPING month AS x, revenue AS y, 'All Categories' AS color FROM all_sales\nDRAW line \n    MAPPING month AS x, revenue AS y, 'Electronics' AS color FROM all_sales \n    FILTER category = 'Electronics'\nDRAW line \n    MAPPING month AS x, revenue AS y, 'Clothing' AS color FROM all_sales \n    FILTER category = 'Clothing'\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Revenue by Category (Filtered Layers)', \n    x =&gt; 'Month', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nMultiple File Sources\nLayers can also reference different CSV files directly:\n\nVISUALISE\nDRAW line \n    MAPPING date AS x, value AS y, 'Time Series' AS color FROM 'timeseries.csv'\nDRAW point \n    MAPPING x AS x, y AS y, 'Scatter' AS color FROM 'data.csv'\nLABEL \n    title =&gt; 'Data from Multiple Files', \n    x =&gt; 'X', \n    y =&gt; 'Y'"
  },
  {
    "objectID": "examples.html#advanced-examples",
    "href": "examples.html#advanced-examples",
    "title": "Examples",
    "section": "Advanced Examples",
    "text": "Advanced Examples\n\nComplete Regional Sales Analysis\n\nSELECT\n    sale_date,\n    region,\n    SUM(quantity) as total_quantity\nFROM 'sales.csv'\nWHERE sale_date &gt;= '2023-01-01'\nGROUP BY sale_date, region\nORDER BY sale_date\nVISUALISE sale_date AS x, total_quantity AS y, region AS color\nDRAW line\nDRAW point\nSCALE x SETTING type =&gt; 'date'\nFACET WRAP region\nLABEL \n    title =&gt; 'Sales Trends by Region', \n    x =&gt; 'Date', \n    y =&gt; 'Total Quantity'\n\n\n\n\n\n\n\nMulti-Category Analysis\n\nSELECT\n    category,\n    region,\n    SUM(revenue) as total_revenue\nFROM 'sales.csv'\nGROUP BY category, region\nVISUALISE category AS x, total_revenue AS y, region AS fill\nDRAW bar\nLABEL \n    title =&gt; 'Revenue by Category and Region', \n    x =&gt; 'Category', \n    y =&gt; 'Revenue ($)'"
  }
]