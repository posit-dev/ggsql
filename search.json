[
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "Installing ggsql",
    "section": "",
    "text": "ggsql is very much still a work in progress and the installation process reflects this. Eventually we will have proper installers but for now please follow this process if you wish to play around with it:\n\nClone the repository:\ngit clone https://github.com/georgestagg/ggsql\ncd ggsql\nInstall tree-sitter CLI:\nnpm install -g tree-sitter-cli\nBuild the project:\ncd tree-sitter-ggsql && tree-sitter generate && cd ..\ncargo build\nInstall the Jupyter kernel:\ncargo run --package ggsql-jupyter -- --install"
  },
  {
    "objectID": "syntax/clause/label.html",
    "href": "syntax/clause/label.html",
    "title": "Define different titles with LABEL",
    "section": "",
    "text": "The LABEL clause is one of the simpler clauses in ggsql an allow you to override the default naming of axes and legends, as well as adding titles to the plot",
    "crumbs": [
      "Home",
      "Main clauses",
      "`LABEL`"
    ]
  },
  {
    "objectID": "syntax/clause/label.html#clause-syntax",
    "href": "syntax/clause/label.html#clause-syntax",
    "title": "Define different titles with LABEL",
    "section": "Clause syntax",
    "text": "Clause syntax\nThe LABEL clause takes one or more labeling settings.\nLABEL &lt;aesthetic/title&gt; =&gt; &lt;string&gt;, ...\nIf an aesthetic is given, then the title will be used for the relevant axis or legend, e.g. x =&gt; 'my x-axis' will label the x axis, whereas fill =&gt; 'Species' will label the legend for fill (if any).\nThere are a few additional labels beside the aesthetics that govern the different titles of the plot and can be given instead of an aesthetic name:\n\ntitle: The main title of the plot\nsubtitle: An additional, often longer and more descriptive, title beneath the main title\ncaption: A string placed below the plot, often used to add additional information about the data source etc.",
    "crumbs": [
      "Home",
      "Main clauses",
      "`LABEL`"
    ]
  },
  {
    "objectID": "syntax/clause/label.html#automatic-labelling-logic",
    "href": "syntax/clause/label.html#automatic-labelling-logic",
    "title": "Define different titles with LABEL",
    "section": "Automatic labelling logic",
    "text": "Automatic labelling logic\nAxes and legends get an automatic label from the mapping. The logic is as follows:\n\nStart from the global mapping and then go through the layer mappings as they appear.\nCollect mappings for each aesthetic in the order they appear\nFor each aesthetic determine the label based on the following priority:\nAn explicitly provided one with LABEL\nThe name of the first appearing column mapping\nThe name of the aesthetic\n\nThis means that constants mapped to an aesthetic doesn’t contribute to the derived label, only data columns, and if all else fails the name of the aesthetic will be used.",
    "crumbs": [
      "Home",
      "Main clauses",
      "`LABEL`"
    ]
  },
  {
    "objectID": "syntax/layer/line.html",
    "href": "syntax/layer/line.html",
    "title": "Line",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nThe line layer is used to create lineplots. Lineplots always connects records along the x-axis, in contrast to path layers which use the order of data to connect records. Lines are divided due to their grouping, which is the combination of the discrete mapped aesthetics and the columns specified in the layers PARTITION BY.",
    "crumbs": [
      "Home",
      "Layers",
      "Line"
    ]
  },
  {
    "objectID": "syntax/layer/line.html#aesthetics",
    "href": "syntax/layer/line.html#aesthetics",
    "title": "Line",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the line layer.\n\nRequired\n\nx: Position along the x-axis\ny: Position along the y-axis\n\n\n\nOptional\n\ncolour/stroke: The colour of the line\nopacity: The opacity of the line\nlinewidth: The width of the line\nlinetype: The type of line, i.e. the dashing pattern",
    "crumbs": [
      "Home",
      "Layers",
      "Line"
    ]
  },
  {
    "objectID": "syntax/layer/line.html#settings",
    "href": "syntax/layer/line.html#settings",
    "title": "Line",
    "section": "Settings",
    "text": "Settings\nThe line layer has no additional settings",
    "crumbs": [
      "Home",
      "Layers",
      "Line"
    ]
  },
  {
    "objectID": "syntax/layer/line.html#data-transformation",
    "href": "syntax/layer/line.html#data-transformation",
    "title": "Line",
    "section": "Data transformation",
    "text": "Data transformation\nThe line layer does not transform its data but passes it through unchanged",
    "crumbs": [
      "Home",
      "Layers",
      "Line"
    ]
  },
  {
    "objectID": "syntax/layer/line.html#examples",
    "href": "syntax/layer/line.html#examples",
    "title": "Line",
    "section": "Examples",
    "text": "Examples\nStandard lineplot\n\nVISUALISE FROM ggsql:airquality\nDRAW line\n    MAPPING Date AS x, Temp AS y\n\n\n\n\n\nUse PARTITION BY to create multiple lines\n\nVISUALISE FROM ggsql:airquality\nDRAW line\n    MAPPING Day AS x, Temp AS y\n    PARTITION BY Month\n\n\n\n\n\nor split them with an aesthetic\n\nVISUALISE FROM ggsql:airquality\nDRAW line\n    MAPPING Day AS x, Temp AS y, Month AS color",
    "crumbs": [
      "Home",
      "Layers",
      "Line"
    ]
  },
  {
    "objectID": "syntax/layer/bar.html",
    "href": "syntax/layer/bar.html",
    "title": "Bar",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nThe bar layer is used to create bar plots. You can either specify the height of the bars directly or let the layer calculate it either as the count of records within the same group or as a weighted sum of the records.",
    "crumbs": [
      "Home",
      "Layers",
      "Bar"
    ]
  },
  {
    "objectID": "syntax/layer/bar.html#aesthetics",
    "href": "syntax/layer/bar.html#aesthetics",
    "title": "Bar",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the bar layer.\n\nRequired\nThe bar layer has no required aesthetics\n\n\nOptional\n\nx: Position on the x-axis. If missing all records will be shown in the same bar\ny: The height of the plot. If missing, it will be calculated by the layer\ncolour: The default colour of each bar\nstroke: The colour of the stroke around each bar. Overrides colour\nfill: The fill colour of each bar. Overrides colour\nopacity: The opacity of the bar fill\nlinewidth: The width of the stroke\nlinetype: The type of stroke, i.e. the dashing pattern",
    "crumbs": [
      "Home",
      "Layers",
      "Bar"
    ]
  },
  {
    "objectID": "syntax/layer/bar.html#settings",
    "href": "syntax/layer/bar.html#settings",
    "title": "Bar",
    "section": "Settings",
    "text": "Settings\n\nwidth: The width of the bars as a proportion of the available width",
    "crumbs": [
      "Home",
      "Layers",
      "Bar"
    ]
  },
  {
    "objectID": "syntax/layer/bar.html#data-transformation",
    "href": "syntax/layer/bar.html#data-transformation",
    "title": "Bar",
    "section": "Data transformation",
    "text": "Data transformation\nIf y has not been mapped the layer will calculate it for you.\n\nProperties\n\nweight: If mapped, the sum of the weights within each group is calculated instead of the count in each group\n\n\n\nCalculated statistics\n\ncount: The count or, if weight have been mapped, sum of weights in each group.\nproportion: The groupwise proportion, i.e. the count divided by the sum of count within each group\n\n\n\nDefault remappings\n\ncount AS y: By default the barplot will show count as the height of the bars",
    "crumbs": [
      "Home",
      "Layers",
      "Bar"
    ]
  },
  {
    "objectID": "syntax/layer/bar.html#examples",
    "href": "syntax/layer/bar.html#examples",
    "title": "Bar",
    "section": "Examples",
    "text": "Examples\nShow the number of each species in the data\n\nVISUALISE FROM ggsql:penguins\nDRAW bar\n    MAPPING species AS x\n\n\n\n\n\nUse weight to instead show the collective mass of each species\n\nVISUALISE FROM ggsql:penguins\nDRAW bar\n    MAPPING species AS x, body_mass AS weight\n\n\n\n\n\nMap fill to a discrete value to create a stacked bar chart\n\nVISUALISE FROM ggsql:penguins\nDRAW bar\n    MAPPING species AS x, island AS fill\n\n\n\n\n\nMap to y if the dataset already contains the value you want to show\n\nSELECT species, MAX(body_mass) AS max_mass FROM ggsql:penguins\nGROUP BY species\nVISUALISE\nDRAW bar\n    MAPPING species AS x, max_mass AS y",
    "crumbs": [
      "Home",
      "Layers",
      "Bar"
    ]
  },
  {
    "objectID": "syntax/layer/point.html",
    "href": "syntax/layer/point.html",
    "title": "Point",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nThe point layer is used to create scatterplots. The scatterplot is most useful for displaying the relationship between two continuous variables. A bubblechart is a scatterplot with a third variable mapped to the size of points.",
    "crumbs": [
      "Home",
      "Layers",
      "Point"
    ]
  },
  {
    "objectID": "syntax/layer/point.html#aesthetics",
    "href": "syntax/layer/point.html#aesthetics",
    "title": "Point",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the point layer.\n\nRequired\n\nx: Position along the x-axis\ny: Position along the y-axis\n\n\n\nOptional\n\nsize: The size of each point\ncolour: The default colour of each point\nstroke: The colour of the stroke around each point (if any). Overrides colour\nfill: The fill colour of each point (if any). Overrides colour\nopacity: The opacity of the point\nshape: The shape used to draw the point",
    "crumbs": [
      "Home",
      "Layers",
      "Point"
    ]
  },
  {
    "objectID": "syntax/layer/point.html#settings",
    "href": "syntax/layer/point.html#settings",
    "title": "Point",
    "section": "Settings",
    "text": "Settings\nThe point layer has no additional settings",
    "crumbs": [
      "Home",
      "Layers",
      "Point"
    ]
  },
  {
    "objectID": "syntax/layer/point.html#data-transformation",
    "href": "syntax/layer/point.html#data-transformation",
    "title": "Point",
    "section": "Data transformation",
    "text": "Data transformation\nThe point layer does not transform its data but passes it through unchanged",
    "crumbs": [
      "Home",
      "Layers",
      "Point"
    ]
  },
  {
    "objectID": "syntax/layer/point.html#examples",
    "href": "syntax/layer/point.html#examples",
    "title": "Point",
    "section": "Examples",
    "text": "Examples\nCreate a classic scatterplot\n\nVISUALISE FROM ggsql:penguins\nDRAW point\n    MAPPING bill_len AS x, bill_dep AS y, species AS fill\n    SETTING size =&gt; 30\n\n\n\n\n\nMap to size to create a bubble chart\n\nVISUALISE FROM ggsql:penguins\nDRAW point\n    MAPPING bill_len AS x, bill_dep AS y, body_mass AS size\n\n\n\n\n\nUse filter to only plot a subset of the data\n\nVISUALISE FROM ggsql:penguins\nDRAW point\n    MAPPING bill_len AS x, bill_dep AS y, species AS fill\n    SETTING size =&gt; 30\n    FILTER sex = 'female'",
    "crumbs": [
      "Home",
      "Layers",
      "Point"
    ]
  },
  {
    "objectID": "syntax/layer/boxplot.html",
    "href": "syntax/layer/boxplot.html",
    "title": "Boxplot",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nBoxplots display a summary of a continuous distribution. In the style of Tukey, it displays the median, two hinges and two whiskers as well as outlying points.",
    "crumbs": [
      "Home",
      "Layers",
      "Boxplot"
    ]
  },
  {
    "objectID": "syntax/layer/boxplot.html#aesthetics",
    "href": "syntax/layer/boxplot.html#aesthetics",
    "title": "Boxplot",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the boxplot layer.\n\nRequired\n\nx: Position on the x-axis\ny: Position on the y-axis\n\n\n\nOptional\n\nstroke: The colour of the box contours, whiskers, median line and outliers.\nfill: The colour of the box interior.\ncolour: Shorthand for setting stroke and fill simultaneously. Note that the median line will have bad visibility if stroke and fill are the same.\nopacity: The opacity of the box interior.\nlinewidth The width of the box outline, whiskers, median line and outlier stroke.\nlinetype The linetype of the box outline, whiskers, median line and outlier stroke.\nsize The absolute size of outlier points.\nshape The shape of outlier points.",
    "crumbs": [
      "Home",
      "Layers",
      "Boxplot"
    ]
  },
  {
    "objectID": "syntax/layer/boxplot.html#settings",
    "href": "syntax/layer/boxplot.html#settings",
    "title": "Boxplot",
    "section": "Settings",
    "text": "Settings\n\noutliers: Whether to display outliers as points. Defaults to true.\ncoef: A number indicating the length of the whiskers as a multiple of the interquartile range (IQR). Defaults to 1.5.\nwidth: Relative width of the boxes. Defaults to 0.9.",
    "crumbs": [
      "Home",
      "Layers",
      "Boxplot"
    ]
  },
  {
    "objectID": "syntax/layer/boxplot.html#data-transformation",
    "href": "syntax/layer/boxplot.html#data-transformation",
    "title": "Boxplot",
    "section": "Data transformation",
    "text": "Data transformation\nPer group, data will be divided into 4 quartiles and summary statistics will be derived from their extremes. Because number of observations per quartile may differ by one, the result of this approach may slightly differ from a pure quantile-based approach. The central line represents the median. The boxes are displayed from the 25th up to the 75th percentiles. The whiskers are calculated from the 25th/75th percentiles +/- the IQR times coef, but no more extreme than the data extrema. Observations are considered outliers when they are more extreme than the whiskers.\n\nCalculated statistics\n\ntype: A string representing the type of metric (upper,lower,q1,q3,median,outlier).\nvalue: The value corresponding to the metric.\n\n\n\nDefault remapping\n\nvalue AS y: By default the values are displayed along the y-axis.\n\n\n\nExamples\nA basic boxplot showing the bill length per species.\n\nVISUALISE FROM ggsql:penguins\nDRAW boxplot\n  MAPPING species AS x, bill_len AS y\n\n\n\n\n\nAdditional groups will dodge the boxplots.\n\nVISUALISE FROM ggsql:penguins\nDRAW boxplot\n  MAPPING \n    species AS x, \n    bill_len AS y,\n    island AS stroke\n\n\n\n\n\nNarrow boxes by shrinking the width parameter.\n\nVISUALISE FROM ggsql:penguins\nDRAW boxplot\n  MAPPING species AS x, bill_len AS y\n  SETTING width =&gt; 0.2\n\n\n\n\n\nConsider more observations as outliers by setting a smaller coef:\n\nVISUALISE FROM ggsql:penguins\nDRAW boxplot\n  MAPPING species AS x, bill_len AS y\n  SETTING coef =&gt; 0.1",
    "crumbs": [
      "Home",
      "Layers",
      "Boxplot"
    ]
  },
  {
    "objectID": "syntax/index.html",
    "href": "syntax/index.html",
    "title": "Syntax",
    "section": "",
    "text": "ggsql augments the standard SQL syntax with a number of new clauses to describe a visualisation:\n\nVISUALISE initiates the visualisation part of the query\nDRAW adds a new layer to the visualisation\nSCALE specify how an aesthetic should be scaled\nFACET describes how data should be split into small multiples\nPROJECT is used for selecting the coordinate system to use\nLABEL is used to manually add titles to the plot or the various axes and legends",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "syntax/index.html#main-clauses",
    "href": "syntax/index.html#main-clauses",
    "title": "Syntax",
    "section": "",
    "text": "ggsql augments the standard SQL syntax with a number of new clauses to describe a visualisation:\n\nVISUALISE initiates the visualisation part of the query\nDRAW adds a new layer to the visualisation\nSCALE specify how an aesthetic should be scaled\nFACET describes how data should be split into small multiples\nPROJECT is used for selecting the coordinate system to use\nLABEL is used to manually add titles to the plot or the various axes and legends",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "syntax/index.html#layers",
    "href": "syntax/index.html#layers",
    "title": "Syntax",
    "section": "Layers",
    "text": "Layers\nThere are many different layers to choose from when visualising your data. Some are straightforward translations of your data into visual marks such as a point layer, while others perform more or less complicated calculations like e.g. the histogram layer. A layer is selected by providing the layer name after the DRAW clause\n\npoint is used to create a scatterplot layer\nline is used to produce lineplots with the data sorted along the x axis\npath is like line above but does not sort the data but plot it according to its own order\narea is used to display series as an area chart.\nribbon is used to display series extrema.\nbar creates a bar chart, optionally calculating y from the number of records in each bar\nhistogram bins the data along the x axis and produces a bar for each bin showing the number of records in it\nboxplot displays continuous variables as 5-number summaries",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "syntax/index.html#scales",
    "href": "syntax/index.html#scales",
    "title": "Syntax",
    "section": "Scales",
    "text": "Scales",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "syntax/index.html#coordinate-systems",
    "href": "syntax/index.html#coordinate-systems",
    "title": "Syntax",
    "section": "Coordinate systems",
    "text": "Coordinate systems",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "syntax/layer/ribbon.html",
    "href": "syntax/layer/ribbon.html",
    "title": "Ribbon",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nThe ribbon layer is used to display extrema over a sorted x-axis. It can be seen as an area chart that is unanchored from zero.",
    "crumbs": [
      "Home",
      "Layers",
      "Ribbon"
    ]
  },
  {
    "objectID": "syntax/layer/ribbon.html#aesthetics",
    "href": "syntax/layer/ribbon.html#aesthetics",
    "title": "Ribbon",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the ribbon layer.\n\nRequired\n\nx: Position along the x-axis\nymin: Lower position along the y-axis.\nymax: Upper position along the y-axis.\n\n\n\nOptional\n\nstroke: The colour of the contour lines.\nfill: The colour of the inner area.\ncolour: Shorthand for setting stroke and fill simultaneously.\nopacity: The opacity of the colours.\nlinewidth: The width of the contour lines.",
    "crumbs": [
      "Home",
      "Layers",
      "Ribbon"
    ]
  },
  {
    "objectID": "syntax/layer/ribbon.html#settings",
    "href": "syntax/layer/ribbon.html#settings",
    "title": "Ribbon",
    "section": "Settings",
    "text": "Settings\nThe ribbon layer has no additional settings.",
    "crumbs": [
      "Home",
      "Layers",
      "Ribbon"
    ]
  },
  {
    "objectID": "syntax/layer/ribbon.html#data-transformation",
    "href": "syntax/layer/ribbon.html#data-transformation",
    "title": "Ribbon",
    "section": "Data transformation",
    "text": "Data transformation\nThe ribbon layer does not transform its data but passes it through unchanged.",
    "crumbs": [
      "Home",
      "Layers",
      "Ribbon"
    ]
  },
  {
    "objectID": "syntax/layer/ribbon.html#examples",
    "href": "syntax/layer/ribbon.html#examples",
    "title": "Ribbon",
    "section": "Examples",
    "text": "Examples\nA ribbon plot with arbitrary values as minima/maxima\n\nVISUALISE FROM ggsql:airquality\n  DRAW ribbon\n    MAPPING Date AS x, Wind AS ymin, Temp AS ymax\n\n\n\n\n\nRibbon plots are great for showing the range of some aggregation.\n\n// Weekly aggregation of temperature\nSELECT \n  WEEKOFYEAR(Date) AS Week, \n  MAX(Temp) AS MaxTemp, \n  MEAN(Temp) AS MeanTemp,\n  MIN(Temp) AS MinTemp \nFROM ggsql:airquality\nGROUP BY WEEKOFYEAR(Date)\n\nVISUALISE Week AS x\n  DRAW ribbon \n    MAPPING MinTemp AS ymin, MaxTemp AS ymax\n    SETTING opacity =&gt; 0.5\n  DRAW line\n    MAPPING MeanTemp AS y",
    "crumbs": [
      "Home",
      "Layers",
      "Ribbon"
    ]
  },
  {
    "objectID": "syntax/layer/area.html",
    "href": "syntax/layer/area.html",
    "title": "Area",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nThe area layer is used to display absolute amounts over a sorted x-axis. It can be seen as a ribbon layer where the ymin is anchored at zero.",
    "crumbs": [
      "Home",
      "Layers",
      "Area"
    ]
  },
  {
    "objectID": "syntax/layer/area.html#aesthetics",
    "href": "syntax/layer/area.html#aesthetics",
    "title": "Area",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the area layer.\n\nRequired\n\nx: Position along the x-axis.\ny: Position along the y-axis.\n\n\n\nOptional\n\nstroke: The colour of the contour lines.\nfill: The colour of the inner area.\ncolour: Shorthand for setting stroke and fill simultaneously.\nopacity: The opacity of the colours.\nlinewidth: The width of the contour lines.",
    "crumbs": [
      "Home",
      "Layers",
      "Area"
    ]
  },
  {
    "objectID": "syntax/layer/area.html#settings",
    "href": "syntax/layer/area.html#settings",
    "title": "Area",
    "section": "Settings",
    "text": "Settings\n\nstacking: Determines how multiple groups are displayed. One of the following:\n\n'off': The groups y-values are displayed as-is (default).\n'on': The y-values are stacked per x position, accumulating over groups.\n'fill': Like 'on' but displayed as a fraction of the total per x position.",
    "crumbs": [
      "Home",
      "Layers",
      "Area"
    ]
  },
  {
    "objectID": "syntax/layer/area.html#data-transformation",
    "href": "syntax/layer/area.html#data-transformation",
    "title": "Area",
    "section": "Data transformation",
    "text": "Data transformation\nThe area layer does not transform its data but passes it through unchanged.",
    "crumbs": [
      "Home",
      "Layers",
      "Area"
    ]
  },
  {
    "objectID": "syntax/layer/area.html#examples",
    "href": "syntax/layer/area.html#examples",
    "title": "Area",
    "section": "Examples",
    "text": "Examples\nCreate a typical area chart\n\nVISUALISE FROM ggsql:airquality\nDRAW area \n  MAPPING Date AS x, Wind AS y\n\n\n\n\n\nWe can reshape the data to ‘long format’ from our wide format.\n\nCREATE TABLE long_airquality AS\nSELECT * FROM ggsql:airquality\nUNPIVOT(\n  Value FOR Series IN (Temp, Wind)\n) AS u;\n\n\n\n\n\n\n\nWhich means we can display multiple series at once, by mapping the identifier to an aesthetic.\n\nVISUALISE Date AS x, Value AS y FROM long_airquality\n  DRAW area MAPPING Series AS colour\n\n\n\n\n\nWe can stack the series by using stacking =&gt; 'on'. The line serves as a reference for ‘unstacked’ data.\n\nVISUALISE Date AS x, Value AS y, Series AS colour FROM long_airquality\n  DRAW area SETTING stacking =&gt; 'on', opacity =&gt; 0.5\n  DRAW line\n\n\n\n\n\nWhen stacking =&gt; 'fill' we’re plotting stacked proportions. These only make sense if every series is measured in the same absolute unit. (Wind and temperature have different units and the temperature is not absolute.)\n\nVISUALISE Date AS x, Value AS y, Series AS colour FROM long_airquality\n  DRAW area SETTING stacking =&gt; 'fill'",
    "crumbs": [
      "Home",
      "Layers",
      "Area"
    ]
  },
  {
    "objectID": "syntax/layer/path.html",
    "href": "syntax/layer/path.html",
    "title": "Path",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nThe path layer is used to create lineplots, but contrary to the line layer the data will not be connected along the x-axis. Instead records are connected in the order they appear in the data. Because of this the ordering is quite important and you may want to use the ORDER BY clause to ensure data comes out of the back-end in the desired order. Lines are divided due to their grouping, which is the combination of the discrete mapped aesthetics and the columns specified in the layers PARTITION BY.",
    "crumbs": [
      "Home",
      "Layers",
      "Path"
    ]
  },
  {
    "objectID": "syntax/layer/path.html#aesthetics",
    "href": "syntax/layer/path.html#aesthetics",
    "title": "Path",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the path layer.\n\nRequired\n\nx: Position along the x-axis\ny: Position along the y-axis\n\n\n\nOptional\n\ncolour/stroke: The colour of the path\nopacity: The opacity of the path\nlinewidth: The width of the path\nlinetype: The type of path, i.e. the dashing pattern",
    "crumbs": [
      "Home",
      "Layers",
      "Path"
    ]
  },
  {
    "objectID": "syntax/layer/path.html#settings",
    "href": "syntax/layer/path.html#settings",
    "title": "Path",
    "section": "Settings",
    "text": "Settings\nThe line layer has no additional settings",
    "crumbs": [
      "Home",
      "Layers",
      "Path"
    ]
  },
  {
    "objectID": "syntax/layer/path.html#data-transformation",
    "href": "syntax/layer/path.html#data-transformation",
    "title": "Path",
    "section": "Data transformation",
    "text": "Data transformation\nThe line layer does not transform its data but passes it through unchanged",
    "crumbs": [
      "Home",
      "Layers",
      "Path"
    ]
  },
  {
    "objectID": "syntax/layer/path.html#examples",
    "href": "syntax/layer/path.html#examples",
    "title": "Path",
    "section": "Examples",
    "text": "Examples\nTBD",
    "crumbs": [
      "Home",
      "Layers",
      "Path"
    ]
  },
  {
    "objectID": "syntax/layer/histogram.html",
    "href": "syntax/layer/histogram.html",
    "title": "Histogram",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nVisualise the distribution of a single continuous variable by dividing the x axis into bins and counting the number of observations in each bin. If providing a weight then a weighted histogram is calculated instead.",
    "crumbs": [
      "Home",
      "Layers",
      "Histogram"
    ]
  },
  {
    "objectID": "syntax/layer/histogram.html#aesthetics",
    "href": "syntax/layer/histogram.html#aesthetics",
    "title": "Histogram",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the bar layer.\n\nRequired\n\nx: Position on the x-axis\n\n\n\nOptional\n\ncolour: The default colour of each bar\nstroke: The colour of the stroke around each bar. Overrides colour\nfill: The fill colour of each bar. Overrides colour\nopacity: The opacity of the bar fill\nlinewidth: The width of the stroke\nlinetype: The type of stroke, i.e. the dashing pattern",
    "crumbs": [
      "Home",
      "Layers",
      "Histogram"
    ]
  },
  {
    "objectID": "syntax/layer/histogram.html#settings",
    "href": "syntax/layer/histogram.html#settings",
    "title": "Histogram",
    "section": "Settings",
    "text": "Settings\n\nbins: The number of bins to calculate. Defaults to 30\nbinwidth: The width of each bin. If provided it will override the binwidth calculated from bins\nclosed: Either 'left' or 'right' (default). Determines whether the bin intervals are closed to the left or right side",
    "crumbs": [
      "Home",
      "Layers",
      "Histogram"
    ]
  },
  {
    "objectID": "syntax/layer/histogram.html#data-transformation",
    "href": "syntax/layer/histogram.html#data-transformation",
    "title": "Histogram",
    "section": "Data transformation",
    "text": "Data transformation\nThe histogram layer will bin the records in each group and count them. By default it will map the count to y.\n\nProperties\n\nweight: If mapped, the sum of the weights within each bin is calculated instead of the count in each bin\n\n\n\nCalculated statistics\n\ncount: The count or, if weight have been mapped, sum of weights in each bin.\ndensity: The groupwise density, i.e. the count divided by the sum of count among all bins within each group\n\n\n\nDefault remappings\n\ncount AS y: By default the histogram will show count as the height of the bars",
    "crumbs": [
      "Home",
      "Layers",
      "Histogram"
    ]
  },
  {
    "objectID": "syntax/layer/histogram.html#examples",
    "href": "syntax/layer/histogram.html#examples",
    "title": "Histogram",
    "section": "Examples",
    "text": "Examples\nShow the number of each species in the data\n\nVISUALISE FROM ggsql:penguins\nDRAW histogram\n    MAPPING body_mass AS x\n\n\n\n\n\nSplit the histogram in two by mapping sex to fill\n\nVISUALISE FROM ggsql:penguins\nDRAW histogram\n    MAPPING body_mass AS x, sex AS fill\n\n\n\n\n\nMake the two histograms the same scale by remapping to density\n\nVISUALISE FROM ggsql:penguins\nDRAW histogram\n    MAPPING body_mass AS x, sex AS fill\n    REMAPPING density AS y\n\n\n\n\n\nSpecify an exact binwidth if needed\n\nVISUALISE FROM ggsql:penguins\nDRAW histogram\n    MAPPING body_mass AS x\n    SETTING binwidth =&gt; 100",
    "crumbs": [
      "Home",
      "Layers",
      "Histogram"
    ]
  },
  {
    "objectID": "syntax/clause/draw.html",
    "href": "syntax/clause/draw.html",
    "title": "Create layers with DRAW",
    "section": "",
    "text": "DRAW is perhaps the most important clause in ggsql as it defines a layer in your visualisation. A layer is a single instance of a visual representation of a dataset. A visualisation can contain multiple layers, either showing the same dataset in different ways or showing different data in each. Layers are drawn in the order they are defined, so that layers defined first will be behind layers defined last.",
    "crumbs": [
      "Home",
      "Main clauses",
      "`DRAW`"
    ]
  },
  {
    "objectID": "syntax/clause/draw.html#clause-syntax",
    "href": "syntax/clause/draw.html#clause-syntax",
    "title": "Create layers with DRAW",
    "section": "Clause syntax",
    "text": "Clause syntax\nThe DRAW clause takes a number of subclauses, all of them optional if the VISUALISE clause provides a global mapping and data source.\nDRAW &lt;layer-type&gt;\n    MAPPING &lt;mapping&gt;, ... FROM &lt;data-source&gt;\n    REMAPPING &lt;mapping&gt;, ...\n    SETTING &lt;parameter/aesthetic&gt; =&gt; &lt;value&gt;, ...\n    FILTER &lt;condition&gt;\n    PARTITION BY &lt;column&gt;, ...\n    ORDER BY &lt;column&gt;, ...\nThe only required part is the layer type immediately following the DRAW clause, which specifies the type of layer to draw, e.g. point or histogram. It defines how the remaining settings are interpreted. The main syntax page has a list of all available layer types\n\nMAPPING\nMAPPING &lt;mapping&gt;, ... FROM &lt;data-source&gt;\nThe MAPPINGS clause define how data from the dataset are related to visual aesthetics or statistical properties. Multiple mappings can be provided by separating them with a comma. Mapped aesthetics are always scaled by their respective scale. This means that if you map the value ‘red’ to fill, then fill will not take the color red, but whatever the scale decides should represent the string ‘red’. Layer mappings are merged with the global mapping from the VISUALISE clause with the one in the layer taking precedence. This means that it is not necessary to provide any mappings in the DRAW clause if sufficient global mappings are provided.\nMAPPING may have a FROM clause that defines the source of the data. If this is missing the global data source from VISUALISE is used.\nThe mapping can take one of three forms and all three can be mixed in the same MAPPING clause:\n\n&lt;data&gt; AS &lt;aesthetic/property&gt; (explicit mapping)\n&lt;data&gt; (implicit mapping)\n* (wildcard mapping)\n\ndata can be either:\n\nColumn name: If you provide the name of a column in the layer data (or global data in the absence of layer data) then the values in that column are mapped to the aesthetic or property. If the name of the column is the same as the aesthetic or property you can provide it without the following AS &lt;aesthetic/property&gt; (implicit mapping).\nConstant: If you provide a constant like a string, number, or boolean then this value is repeated for every record in the data and mapped to the given aesthetic or property. When mapping a constant you must use the explicit form since the aesthetic/property cannot be derived.\n\nIf an asterisk is given (wildcard mapping) it indicate that every column in the layer data with a name matching a supported aesthetic or property are implicitly mapped to said aesthetic or property. If the aesthetic or property has been mapped elsewhere then that gains precedence (i.e. if writing MAPPING *, revenue AS y then y will take on the data in the revenue column even if a y column exist in the data)\nAn aesthetic is a visual characteristic of what you are rendering. Different aesthetics are available depending on the layer type since e.g. linetype is not relevant for points and shape are not relevant for lines.\nA property is a value used by the statistical transformation done by the layer, e.g. the weight property in the histogram layer that allows weighted histogram calculation.\n\nMapped aesthetics are always scaled by their respective scale, whereas properties are not (there are no scales for properties).\n\nThe documentation for each layer type provides an overview of the aesthetics and properties available for them.\nA layer may use a data source different than the global data by appending a FROM &lt;data-source&gt; to the mapping. The data source can be either:\n\nTable/CTE: If providing an unquoted identifier it is assumed that the data is available in the backend, either as a CTE defined in the pre-query, or as a proper table in the database.\nFilepath: If a string is provided (single quoted), it is assumed to point to a file that can be read directly by the backend.\n\n\n\nREMAPPING\nREMAPPING &lt;mapping&gt;, ...\nSome layer types like histogram runs the data through a statistical transformation in order to arrive at the data that needs to be displayed (e.g. count per bin). During this, one or more columns are added to the data and you can access these in the REMAPPING clause. Layers that perform statistical transformations always have a default remapping (e.g. count AS y in histogram) so it never required to specify a remapping, but you can do so, either to change the default (e.g. density AS yto access the calculated density instead of count), or to use the calculated property for another aesthetic (e.g. count AS fill to also shade the bars according to their height).\nRemappings have to be explicit since the property name never coincide with an aesthetic. Further, remappings must always map to a visual aesthetic since the statistical properties have already been consumed.\n\n\nSETTING\nSETTING &lt;parameter/aesthetic&gt; =&gt; &lt;value&gt;, ...\nThe SETTING clause can be used for to different things:\n\nSetting parameters: Some layers take additional arguments that control how they behave. Often, but not always, these modify the statistical transformation in some way. An example would be the binwidth parameter in histogram which controls the width of each bin during histogram calculation. This is not a statistical property since it is not related to each record, but to the calculation as a whole.\nSetting aesthetics: If you wish to set a specific aesthetic to a literal value, e.g. ‘red’ (as in the color red) then you can do so in the SETTING clause. Aesthetics that are set will not go through a scale but will use the provided value as-is. You cannot set an aesthetic to a column, only to a scalar literal value.\n\n\n\nFILTER\nFILTER &lt;condition&gt;\nYou may not want to use all data provided from the data source in the layer. You can limit the data to plot with the FILTER clause. The content of condition is used directly in a WHERE clause when querying the backend for the layer data, so whatever type of expression you database backend supports there will work.\n\n\nPARTITION BY\nPARTITION BY &lt;column&gt;, ...\nDuring drawing the records in the layer data are grouped by all the discrete data that has been mapped. This grouping is not relevant to all layer types but critical for some, e.g. line layers where the grouping defines which records are connected with a line.\nOften the implicit grouping from the aesthetic mapping is enough, e.g. mapping a discrete value to colour will create one line per colour, but sometimes you need a grouping not reflected in the aesthetic mapping. In that case you can use the PARTITION BY clause to define data columns used for grouping in addition to the ones from the mapping.\n\n\nORDER BY\nORDER BY &lt;column&gt;, ...\nFor some layers the order of records in the data is important, e.g. the path layer which connect records in the order they are provided. Since databases often doesn’t guarantee a specific order of the data, the ORDER BY clause can be used to enforce such and order. Even for layers where the order doesn’t immediately seem to matter it may have an effect, e.g. an overplottet scatterplot where the records in the end of the data are plottet on top of the one in the start.",
    "crumbs": [
      "Home",
      "Main clauses",
      "`DRAW`"
    ]
  },
  {
    "objectID": "syntax/clause/visualise.html",
    "href": "syntax/clause/visualise.html",
    "title": "Initialise a visualisation with VISUALISE",
    "section": "",
    "text": "The VISUALISE (or VISUALIZE) clause marks the beginning of a ggsql visualisation declaration. As such it demarcates where the regular query ends and the visualisation query starts. Everything that comes before the VISUALISE clause is considered a standard SQL query that is sent to the backend. Any CTEs defined therein will be available to the ggsql query, and if it ends with a SELECT query this will automatically be added as the global data for the plot.",
    "crumbs": [
      "Home",
      "Main clauses",
      "`VISUALISE`"
    ]
  },
  {
    "objectID": "syntax/clause/visualise.html#clause-syntax",
    "href": "syntax/clause/visualise.html#clause-syntax",
    "title": "Initialise a visualisation with VISUALISE",
    "section": "Clause syntax",
    "text": "Clause syntax\nThe VISUALISE clause is quite simple and doesn’t take any additional required parameters. You can, however, use it to define global mappings and a global data source (if the earlier query didn’t end in a SELECT).\nVISUALISE &lt;mapping&gt;, ... FROM &lt;data-source&gt;\nFollowing VISUALISE you can provide a series of global mappings. These will be inherited by the layers created with the DRAW clause but can be overwritten by them. Mappings define how data from the dataset are related to visual aesthetics or statistical properties. Multiple mappings can be provided by separating them with a comma. Mapped aesthetics are always scaled by their respective scale. This means that if you map the value ‘red’ to fill, then fill will not take the color red, but whatever the scale decides should represent the string ‘red’.\nVISUALISE may have a FROM clause that defines the source of the global data. If present it overwrites the terminal SELECT clause in the previous query as the global data. Global data is used by layers that do not specify their own data source with MAPPING ... FROM &lt;data-source&gt;.\nThe mapping can take one of three forms and all three can be mixed:\n\n&lt;data&gt; AS &lt;aesthetic/property&gt; (explicit mapping)\n&lt;data&gt; (implicit mapping)\n* (wildcard mapping)\n\ndata can be either:\n\nColumn name: If you provide the name of a column in the data then the values in that column are mapped to the aesthetic or property. If the name of the column is the same as the aesthetic or property you can provide it without the following AS &lt;aesthetic/property&gt; (implicit mapping).\nConstant: If you provide a constant like a string, number, or boolean then this value is repeated for every record in the data and mapped to the given aesthetic or property. When mapping a constant you must use the explicit form since the aesthetic/property cannot be derived.\n\nIf an asterisk is given (wildcard mapping) it indicate that every column in the layer data with a name matching a supported aesthetic or property are implicitly mapped to said aesthetic or property. If the aesthetic or property has been mapped elsewhere then that gains precedence (i.e. if writing VISUALISE *, revenue AS y then y will take on the data in the revenue column even if a y column exist in the data)\nAn aesthetic is a visual characteristic of what you are rendering. Different aesthetics are available depending on the layer type since e.g. linetype is not relevant for points and shape are not relevant for lines.\nA property is a value used by the statistical transformation done by the layer, e.g. the weight property in the histogram layer that allows weighted histogram calculation.\n\nMapped aesthetics are always scaled by their respective scale, whereas properties are not (there are no scales for properties).\n\nLayers only inherit the aesthetics and properties they support from the global mapping. The documentation for each layer type provides an overview of the aesthetics and properties available for them.\nWhen specifying a global data source with FROM &lt;data-source&gt; the data-source can take one of two different forms:\n\nTable/CTE: If providing an unquoted identifier it is assumed that the data is available in the backend, either as a CTE defined in the pre-query, or as a proper table in the database.\nFilepath: If a string is provided (single quoted), it is assumed to point to a file that can be read directly by the backend.",
    "crumbs": [
      "Home",
      "Main clauses",
      "`VISUALISE`"
    ]
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Examples",
    "section": "",
    "text": "This document demonstrates various ggsql features with runnable examples using CSV files."
  },
  {
    "objectID": "examples.html#basic-visualizations",
    "href": "examples.html#basic-visualizations",
    "title": "Examples",
    "section": "Basic Visualizations",
    "text": "Basic Visualizations\n\nSimple Scatter Plot\n\nSELECT x, y FROM 'data.csv'\nVISUALISE x, y\nDRAW point\n\n\n\n\n\n\nVISUALISE bill_len AS x, bill_dep AS y, species AS color FROM ggsql:penguins\nDRAW point\n\n\n\n\n\n\n\nLine Chart with Date Scale\n\nSELECT sale_date, revenue FROM 'sales.csv'\nWHERE category = 'Electronics'\nVISUALISE sale_date AS x, revenue AS y\nDRAW line\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Electronics Revenue Over Time', \n    x =&gt; 'Date', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\nSELECT * FROM ggsql:airquality\nVISUALISE Date AS x\nDRAW line MAPPING Ozone AS y, 'Ozone' AS color\nDRAW line MAPPING Temp AS y, 'Temp' AS color\n\n\n\n\n\n\n\nBar Chart by Category\n\nSELECT category, SUM(revenue) as total\nFROM 'sales.csv'\nGROUP BY category\nVISUALISE category AS x, total AS y, category AS fill\nDRAW bar\nLABEL \n    title =&gt; 'Total Revenue by Category', \n    x =&gt; 'Category', \n    y =&gt; 'Total Revenue ($)'\n\n\n\n\n\n\n\nLine chart with multiple lines with same aesthetics\n\nSELECT * FROM 'sales.csv'\nVISUALISE sale_date AS x, revenue AS y\nDRAW line\n    PARTITION BY category"
  },
  {
    "objectID": "examples.html#statistical-transformations",
    "href": "examples.html#statistical-transformations",
    "title": "Examples",
    "section": "Statistical Transformations",
    "text": "Statistical Transformations\nStatistical transformations automatically compute aggregations for certain geom types.\n\nHistogram\nWhen using DRAW histogram, ggsql automatically bins continuous data and counts occurrences. You only need to specify the x aesthetic:\n\nSELECT revenue FROM 'sales.csv'\nVISUALISE revenue AS x\nDRAW histogram\nLABEL\n    title =&gt; 'Revenue Distribution',\n    x =&gt; 'Revenue ($)',\n    y =&gt; 'Count'\n\n\n\n\n\n\n\nBar with Automatic Count\nWhen using DRAW bar without a y aesthetic, ggsql automatically counts occurrences of each x value:\n\nSELECT category FROM 'sales.csv'\nVISUALISE category AS x\nDRAW bar\nLABEL\n    title =&gt; 'Sales Count by Category',\n    x =&gt; 'Category',\n    y =&gt; 'Count'\n\n\n\n\n\n\n\nBar with Weighted Count\nYou can also specify a weight aesthetic to sum values instead of counting:\n\nSELECT category, revenue FROM 'sales.csv'\nVISUALISE category AS x, revenue AS weight\nDRAW bar\nLABEL\n    title =&gt; 'Total Revenue by Category',\n    x =&gt; 'Category',\n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nHistogram Settings\nControl histogram binning with SETTING options:\nCustom number of bins:\n\nSELECT revenue FROM 'sales.csv'\nVISUALISE revenue AS x\nDRAW histogram \n    SETTING bins =&gt; 10\nLABEL\n    title =&gt; 'Revenue Distribution (10 bins)',\n    x =&gt; 'Revenue ($)',\n    y =&gt; 'Count'\n\n\n\n\n\nExplicit bin width (overrides bins):\n\nSELECT revenue FROM 'sales.csv'\nVISUALISE revenue AS x\nDRAW histogram \n    SETTING binwidth =&gt; 500\nLABEL\n    title =&gt; 'Revenue Distribution (500 bin width)',\n    x =&gt; 'Revenue ($)',\n    y =&gt; 'Count'\n\n\n\n\n\nLeft-closed intervals (default is right-closed (a, b]):\n\nSELECT revenue FROM 'sales.csv'\nVISUALISE revenue AS x\nDRAW histogram \n    SETTING bins =&gt; 8, closed =&gt; 'left'\nLABEL\n    title =&gt; 'Revenue Distribution (left-closed intervals)',\n    x =&gt; 'Revenue ($)',\n    y =&gt; 'Count'\n\n\n\n\n\n\n\nHistogram Remapping\nHistogram computes several statistics: bin, bin_end, count, and density. By default, count is mapped to y. Use REMAPPING to show density (proportion) instead:\n\nSELECT revenue FROM 'sales.csv'\nVISUALISE revenue AS x\nDRAW histogram \n    REMAPPING density AS y\nLABEL\n    title =&gt; 'Revenue Density Distribution',\n    x =&gt; 'Revenue ($)',\n    y =&gt; 'Density'\n\n\n\n\n\n\n\nBar Width Setting\nControl bar width with the width setting (0-1 scale, default 0.9):\n\nSELECT category FROM 'sales.csv'\nVISUALISE category AS x\nDRAW bar \n    SETTING width =&gt; 0.5\nLABEL\n    title =&gt; 'Sales Count (Narrow Bars)',\n    x =&gt; 'Category',\n    y =&gt; 'Count'\n\n\n\n\n\n\n\nBar Remapping\nBar computes count and proportion statistics. By default, count is mapped to y. Use REMAPPING to show proportions instead:\n\nSELECT category FROM 'sales.csv'\nVISUALISE category AS x\nDRAW bar \n    REMAPPING proportion AS y\nLABEL\n    title =&gt; 'Sales Proportion by Category',\n    x =&gt; 'Category',\n    y =&gt; 'Proportion'\n\n\n\n\n\nCombine with weight to show weighted proportions:\n\nSELECT category, revenue FROM 'sales.csv'\nVISUALISE category AS x, revenue AS weight\nDRAW bar \n    REMAPPING proportion AS y\nLABEL\n    title =&gt; 'Revenue Share by Category',\n    x =&gt; 'Category',\n    y =&gt; 'Share of Total Revenue'"
  },
  {
    "objectID": "examples.html#multiple-layers",
    "href": "examples.html#multiple-layers",
    "title": "Examples",
    "section": "Multiple Layers",
    "text": "Multiple Layers\n\nLine with Points\n\nSELECT date, value FROM 'timeseries.csv'\nVISUALISE date AS x, value AS y\nDRAW line \n    SETTING  color =&gt; 'blue'\nDRAW point \n    SETTING size =&gt; 30, color =&gt; 'red'\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Time Series with Points', \n    x =&gt; 'Date', \n    y =&gt; 'Value'\n\n\n\n\n\n\n\nColored Lines by Category\n\nSELECT date, value, category FROM 'metrics.csv'\nVISUALISE date AS x, value AS y, category AS color\nDRAW line\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Metrics by Category', \n    x =&gt; 'Date', \n    y =&gt; 'Value'"
  },
  {
    "objectID": "examples.html#faceting",
    "href": "examples.html#faceting",
    "title": "Examples",
    "section": "Faceting",
    "text": "Faceting\n\nFacet Wrap by Region\n\nSELECT sale_date, revenue, region FROM 'sales.csv'\nWHERE category = 'Electronics'\nVISUALISE sale_date AS x, revenue AS y\nDRAW line\nSCALE x SETTING type =&gt; 'date'\nFACET WRAP region\nLABEL \n    title =&gt; 'Electronics Sales by Region', \n    x =&gt; 'Date', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nFacet Grid\n\nSELECT\n    DATE_TRUNC('month', sale_date) as month,\n    region,\n    category,\n    SUM(revenue) as total_revenue,\n    SUM(quantity) * 100 as total_quantity_scaled\nFROM 'sales.csv'\nGROUP BY DATE_TRUNC('month', sale_date), region, category\nVISUALISE month AS x\nDRAW line \n    MAPPING total_revenue AS y\n    SETTING color =&gt; 'steelblue'\nDRAW point \n    MAPPING total_revenue AS y\n    SETTING size =&gt; 30, color =&gt; 'darkblue'\nDRAW line \n    MAPPING total_quantity_scaled AS y\n    SETTING color =&gt; 'coral'\nDRAW point \n    MAPPING total_quantity_scaled AS y\n    SETTING size =&gt; 30, color =&gt; 'orangered'\nSCALE x SETTING type =&gt; 'date'\nFACET region BY category\nLABEL \n    title =&gt; 'Monthly Revenue and Quantity by Region and Category', \n    x =&gt; 'Month', \n    y =&gt; 'Value'"
  },
  {
    "objectID": "examples.html#coordinate-transformations",
    "href": "examples.html#coordinate-transformations",
    "title": "Examples",
    "section": "Coordinate Transformations",
    "text": "Coordinate Transformations\n\nFlipped Coordinates (Horizontal Bar Chart)\n\nSELECT region, SUM(revenue) as total\nFROM 'sales.csv'\nGROUP BY region\nORDER BY total DESC\nVISUALISE region AS x, total AS y, region AS fill\nDRAW bar\nCOORD flip\nLABEL \n    title =&gt; 'Total Revenue by Region', \n    x =&gt; 'Region', \n    y =&gt; 'Total Revenue ($)'\n\n\n\n\n\n\n\nCartesian with Axis Limits\n\nSELECT x, y FROM 'data.csv'\nVISUALISE x, y\nDRAW point \n    SETTING size =&gt; 4, color =&gt; 'blue'\nCOORD cartesian \n    SETTING xlim =&gt; [0, 60], ylim =&gt; [0, 70]\nLABEL \n    title =&gt; 'Scatter Plot with Custom Axis Limits', \n    x =&gt; 'X', \n    y =&gt; 'Y'\n\n\n\n\n\n\n\nPie Chart with Polar Coordinates\n\nSELECT category, SUM(revenue) as total\nFROM 'sales.csv'\nGROUP BY category\nVISUALISE total AS y, category AS fill\nDRAW bar\nCOORD polar\nLABEL \n    title =&gt; 'Revenue Distribution by Category'"
  },
  {
    "objectID": "examples.html#constant-mappings",
    "href": "examples.html#constant-mappings",
    "title": "Examples",
    "section": "Constant Mappings",
    "text": "Constant Mappings\nConstants can be used in both the VISUALISE clause (global) and MAPPING clauses (per-layer) to set fixed aesthetic values.\n\nDifferent Constants Per Layer\nEach layer can have its own constant value, creating a legend showing all values:\n\nWITH monthly AS (\n    SELECT\n        DATE_TRUNC('month', sale_date) as month,\n        category,\n        SUM(revenue) as revenue\n    FROM 'sales.csv'\n    GROUP BY DATE_TRUNC('month', sale_date), category\n)\nVISUALISE month AS x, revenue AS y\nDRAW line \n    MAPPING 'Electronics' AS color FROM monthly \n    FILTER category = 'Electronics'\nDRAW line \n    MAPPING 'Clothing' AS color FROM monthly \n    FILTER category = 'Clothing'\nDRAW line \n    MAPPING 'Furniture' AS color FROM monthly \n    FILTER category = 'Furniture'\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Revenue by Category (Constant Colors)', \n    x =&gt; 'Month', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nMixed Constants and Columns\nWhen mixing constant and column mappings for the same aesthetic, the axis/legend label uses the first non-constant column name:\n\nSELECT date, value, category FROM 'metrics.csv'\nVISUALISE date AS x\nDRAW line \n    MAPPING value AS y, category AS color\nDRAW point \n    MAPPING 120 AS y \n    SETTING size =&gt; 20, color =&gt; 'blue'\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Metrics with Threshold Line', \n    x =&gt; 'Date'\n\n\n\n\n\n\n\nNumeric Constants\nNumbers work as constants too:\n\nSELECT x, y FROM 'data.csv'\nVISUALISE x, y\nDRAW point \n    SETTING color =&gt; 'blue', size =&gt; 100\nDRAW point \n    SETTING color =&gt; 'red', size =&gt; 50 \n    FILTER y &gt; 50\nLABEL \n    title =&gt; 'Scatter Plot with Constant Sizes'"
  },
  {
    "objectID": "examples.html#layer-filtering",
    "href": "examples.html#layer-filtering",
    "title": "Examples",
    "section": "Layer filtering",
    "text": "Layer filtering\n\nFilter one layer\n\nSELECT date, value FROM 'timeseries.csv'\nVISUALISE date AS x, value AS y\nDRAW line \n    SETTING color =&gt; 'blue'\nDRAW point \n    SETTING color =&gt; 'red', size =&gt; 30 \n    FILTER value &lt; 130\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Time Series with Points', \n    x =&gt; 'Date', \n    y =&gt; 'Value'"
  },
  {
    "objectID": "examples.html#layer-ordering",
    "href": "examples.html#layer-ordering",
    "title": "Examples",
    "section": "Layer ordering",
    "text": "Layer ordering\n\nORDER BY in a layer\nUse ORDER BY to ensure data is sorted correctly within a layer. This is especially important for line charts where the order of points affects the visual path:\n\nWITH unordered_data AS (\n    SELECT * FROM (VALUES\n        (150.0, '2023-03-01'::DATE),\n        (100.0, '2023-01-01'::DATE),\n        (120.0, '2023-05-01'::DATE),\n        (200.0, '2023-02-01'::DATE),\n        (180.0, '2023-04-01'::DATE)\n    ) AS t(value, date)\n)\nVISUALISE\nDRAW path \n    MAPPING date AS x, value AS y FROM unordered_data \n    ORDER BY date\nDRAW point \n    MAPPING date AS x, value AS y FROM unordered_data \n    SETTING size =&gt; 40, color =&gt; 'red'\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Line Chart with ORDER BY', \n    x =&gt; 'Date', \n    y =&gt; 'Value'\n\n\n\n\n\n\n\nCombining FILTER and ORDER BY\nThe ORDER BY clause can be combined with FILTER and other layer options:\n\nSELECT date, value, category FROM 'metrics.csv'\nVISUALISE\nDRAW path \n    MAPPING date AS x, value AS y, category AS color \n    FILTER category != 'Support' \n    ORDER BY value\nDRAW point \n    MAPPING date AS x, value AS y, category AS color \n    SETTING size =&gt; 20 \n    FILTER category != 'Support' \nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Sales and Marketing Metrics (Ordered)', \n    x =&gt; 'Date', \n    y =&gt; 'Value'"
  },
  {
    "objectID": "examples.html#common-table-expressions-ctes",
    "href": "examples.html#common-table-expressions-ctes",
    "title": "Examples",
    "section": "Common Table Expressions (CTEs)",
    "text": "Common Table Expressions (CTEs)\n\nSimple CTE with VISUALISE FROM\n\nWITH monthly_sales AS (\n    SELECT\n        DATE_TRUNC('month', sale_date) as month,\n        SUM(revenue) as total_revenue\n    FROM 'sales.csv'\n    GROUP BY DATE_TRUNC('month', sale_date)\n)\nVISUALISE month AS x, total_revenue AS y FROM monthly_sales\nDRAW line\nDRAW point\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Monthly Revenue Trends', \n    x =&gt; 'Month', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nMultiple CTEs\n\nWITH daily_sales AS (\n    SELECT sale_date, region, SUM(revenue) as revenue\n    FROM 'sales.csv'\n    GROUP BY sale_date, region\n),\nregional_totals AS (\n    SELECT region, SUM(revenue) as total\n    FROM daily_sales\n    GROUP BY region\n)\nVISUALISE region AS x, total AS y, region AS fill FROM regional_totals\nDRAW bar\nCOORD flip\nLABEL \n    title =&gt; 'Total Revenue by Region', \n    x =&gt; 'Region', \n    y =&gt; 'Total Revenue ($)'"
  },
  {
    "objectID": "examples.html#layer-specific-data-sources-mapping-from",
    "href": "examples.html#layer-specific-data-sources-mapping-from",
    "title": "Examples",
    "section": "Layer-Specific Data Sources (MAPPING FROM)",
    "text": "Layer-Specific Data Sources (MAPPING FROM)\nLayers can pull data from different sources using MAPPING FROM. This enables overlaying data from different CTEs or tables.\n\nComparing Actuals vs Targets\nEach layer can reference a different CTE using MAPPING ... FROM cte_name:\n\nWITH actuals AS (\n    SELECT\n        DATE_TRUNC('month', sale_date) as month,\n        SUM(revenue) as value\n    FROM 'sales.csv'\n    GROUP BY DATE_TRUNC('month', sale_date)\n),\ntargets AS (\n    SELECT * FROM (VALUES\n        ('2023-01-01'::DATE, 5000.0),\n        ('2023-02-01'::DATE, 5500.0),\n        ('2023-03-01'::DATE, 6000.0),\n        ('2023-04-01'::DATE, 6500.0),\n        ('2023-05-01'::DATE, 7000.0),\n        ('2023-06-01'::DATE, 7500.0),\n        ('2023-07-01'::DATE, 8000.0),\n        ('2023-08-01'::DATE, 8500.0),\n        ('2023-09-01'::DATE, 9000.0),\n        ('2023-10-01'::DATE, 9500.0),\n        ('2023-11-01'::DATE, 10000.0),\n        ('2023-12-01'::DATE, 10500.0)\n    ) AS t(month, value)\n)\nVISUALISE\nDRAW line \n    MAPPING month AS x, value AS y, 'Actual' AS color FROM actuals\nDRAW point \n    MAPPING month AS x, value AS y, 'Actual' AS color FROM actuals \n    SETTING size =&gt; 30\nDRAW line \n    MAPPING month AS x, value AS y, 'Target' AS color FROM targets\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Revenue: Actual vs Target', \n    x =&gt; 'Month', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nCTE Chain: Raw → Filtered → Aggregated\nCTEs can reference other CTEs, creating a data transformation pipeline:\n\nWITH raw_data AS (\n    SELECT sale_date, revenue, category, region\n    FROM 'sales.csv'\n),\nelectronics_only AS (\n    SELECT * FROM raw_data\n    WHERE category = 'Electronics'\n),\nmonthly_electronics AS (\n    SELECT\n        DATE_TRUNC('month', sale_date) as month,\n        region,\n        SUM(revenue) as total\n    FROM electronics_only\n    GROUP BY DATE_TRUNC('month', sale_date), region\n)\nVISUALISE month AS x, total AS y, region AS color FROM monthly_electronics\nDRAW line\nDRAW point\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Electronics Revenue by Region (CTE Chain)', \n    x =&gt; 'Month', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nLayer FROM with FILTER\nCombine FROM with FILTER to get filtered subsets from a CTE:\n\nWITH all_sales AS (\n    SELECT\n        DATE_TRUNC('month', sale_date) as month,\n        category,\n        SUM(revenue) as revenue\n    FROM 'sales.csv'\n    GROUP BY DATE_TRUNC('month', sale_date), category\n)\nVISUALISE\nDRAW line \n    MAPPING month AS x, revenue AS y, 'All Categories' AS color FROM all_sales\nDRAW line \n    MAPPING month AS x, revenue AS y, 'Electronics' AS color FROM all_sales \n    FILTER category = 'Electronics'\nDRAW line \n    MAPPING month AS x, revenue AS y, 'Clothing' AS color FROM all_sales \n    FILTER category = 'Clothing'\nSCALE x SETTING type =&gt; 'date'\nLABEL \n    title =&gt; 'Revenue by Category (Filtered Layers)', \n    x =&gt; 'Month', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nMultiple File Sources\nLayers can also reference different CSV files directly:\n\nVISUALISE\nDRAW line \n    MAPPING date AS x, value AS y, 'Time Series' AS color FROM 'timeseries.csv'\nDRAW point \n    MAPPING x AS x, y AS y, 'Scatter' AS color FROM 'data.csv'\nLABEL \n    title =&gt; 'Data from Multiple Files', \n    x =&gt; 'X', \n    y =&gt; 'Y'"
  },
  {
    "objectID": "examples.html#advanced-examples",
    "href": "examples.html#advanced-examples",
    "title": "Examples",
    "section": "Advanced Examples",
    "text": "Advanced Examples\n\nComplete Regional Sales Analysis\n\nSELECT\n    sale_date,\n    region,\n    SUM(quantity) as total_quantity\nFROM 'sales.csv'\nWHERE sale_date &gt;= '2023-01-01'\nGROUP BY sale_date, region\nORDER BY sale_date\nVISUALISE sale_date AS x, total_quantity AS y, region AS color\nDRAW line\nDRAW point\nSCALE x SETTING type =&gt; 'date'\nFACET WRAP region\nLABEL \n    title =&gt; 'Sales Trends by Region', \n    x =&gt; 'Date', \n    y =&gt; 'Total Quantity'\n\n\n\n\n\n\n\nMulti-Category Analysis\n\nSELECT\n    category,\n    region,\n    SUM(revenue) as total_revenue\nFROM 'sales.csv'\nGROUP BY category, region\nVISUALISE category AS x, total_revenue AS y, region AS fill\nDRAW bar\nLABEL \n    title =&gt; 'Revenue by Category and Region', \n    x =&gt; 'Category', \n    y =&gt; 'Revenue ($)'"
  }
]