[
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "Installing ggsql",
    "section": "",
    "text": "If you prefer to build from source or need the latest development version:\n\nClone the repository:\ngit clone https://github.com/posit-dev/ggsql\ncd ggsql\nInstall tree-sitter CLI:\nnpm install -g tree-sitter-cli\nBuild the project:\ncd tree-sitter-ggsql && tree-sitter generate && cd ..\ncargo build --release\nInstall the CLI:\ncargo install --path src\nInstall the Jupyter kernel (optional):\ncargo install --path ggsql-jupyter\nggsql-jupyter --install"
  },
  {
    "objectID": "installation.html#building-from-source",
    "href": "installation.html#building-from-source",
    "title": "Installing ggsql",
    "section": "",
    "text": "If you prefer to build from source or need the latest development version:\n\nClone the repository:\ngit clone https://github.com/posit-dev/ggsql\ncd ggsql\nInstall tree-sitter CLI:\nnpm install -g tree-sitter-cli\nBuild the project:\ncd tree-sitter-ggsql && tree-sitter generate && cd ..\ncargo build --release\nInstall the CLI:\ncargo install --path src\nInstall the Jupyter kernel (optional):\ncargo install --path ggsql-jupyter\nggsql-jupyter --install"
  },
  {
    "objectID": "syntax/scale/aesthetic/2_opacity.html",
    "href": "syntax/scale/aesthetic/2_opacity.html",
    "title": "Opacity",
    "section": "",
    "text": "The opacity aesthetic governs how opaque objects are (or, conversely, how transparent they are). Depending on the layer it controls the opacity of the fill or stroke (if a layer has a natural fill then that is what receives the opacity). Opacity goes from 0 (fully transparent) to 1 (fully opaque).\nColor values (fill or stroke aesthetics) may contain opacity information embedded, e.g. by using hex values with an alpha channel. How such colors are merged with the opacity aesthetic is writer-dependent and can’t be relied on. Even if the behavior was consistent, mixing the two is never a good idea because it leads to hard-to-decode graphics.",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Opacity"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/2_opacity.html#literal-values",
    "href": "syntax/scale/aesthetic/2_opacity.html#literal-values",
    "title": "Opacity",
    "section": "Literal values",
    "text": "Literal values\nOpacity has no unit and goes from 0 (fully transparent) to 1 (fully opaque). You can set the opacity of points to a low value to combat overplotting like so:\nDRAW point\n    SETTING opacity =&gt; 0.2",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Opacity"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/2_opacity.html#palettes",
    "href": "syntax/scale/aesthetic/2_opacity.html#palettes",
    "title": "Opacity",
    "section": "Palettes",
    "text": "Palettes\nOpacity can only be used for sequential data and has no named palettes. The default for continuous, binned, and ordinal scales is to use the range from 0.1 to 1 and interpolate between them. This can be overwritten by providing a manual output range specification like below where we use the complete range opacity",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Opacity"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/1_color.html",
    "href": "syntax/scale/aesthetic/1_color.html",
    "title": "Fill and Stroke",
    "section": "",
    "text": "Color values are used in two places in ggsql: When setting stroke color and fill color. Stroke color governs the color of lines, be it the outline of a rectangle (e.g. in a bar layer), or the line of a path (e.g. in a line layer). The fill color determines the color of the inside of a shape. It follows that all layers respond to the stroke aesthetic but only those containing closed shapes respond to the fill aesthetic.",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Fill and Stroke"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/1_color.html#the-color-meta-aesthetic",
    "href": "syntax/scale/aesthetic/1_color.html#the-color-meta-aesthetic",
    "title": "Fill and Stroke",
    "section": "The color meta-aesthetic",
    "text": "The color meta-aesthetic\nIn addition to the fill and stroke aesthetics there is also a color meta-aesthetic. Setting this will set the fill and stroke at the same time unless they are set directly. For instance, the following will set the fill and stroke to red\nDRAW bar\n    SETTING color =&gt; 'red'\nwhereas this will set the fill to red and stroke to black\nDRAW bar\n    SETTING color =&gt; 'red', stroke =&gt; 'black'\nThe same logic applies when defining a scale. Defining a color scale creates two scales, one for fill and one for stroke, with the same settings (unless either are defined explicitly). For instance, the following\nSCALE color TO viridis\ndefines two separate scales for fill and stroke that both use the viridis palette.\nIn general, it is highly advisable to be explicit and directly use the fill and stroke aesthetics. The color meta-aesthetic is a quick shortcut if you need it.",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Fill and Stroke"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/1_color.html#literal-values",
    "href": "syntax/scale/aesthetic/1_color.html#literal-values",
    "title": "Fill and Stroke",
    "section": "Literal values",
    "text": "Literal values\nLiteral color values can be defined in any CSS compatible way 1. The gist of it is that colors can be defined in one of three different ways:\n\nAs a named color, e.g. 'red', or 'lemonchiffon'\nAs a hex color value, e.g. '#FF0000' or '#FFFACD88'\nAs a css color function, e.g. 'rgba(100%, 0%, 0%, 50%)' or 'oklab(98%, -0.012, 0.057)'\n\nLiteral color values are used in three places in ggsql. Either when setting an aesthetic (as opposed to mapping), e.g.\nDRAW line\n    SETTING stroke =&gt; '#FF0000'\nwhen you define the output range of a fill or stroke scale manually, e.g.\nSCALE fill TO ['rgb(100%, 0%, 0%)', 'lemonchiffon']\nor when using an identity scale for color in which case the data values must be parsable as colors.\nNote that all different types of color notation can be mixed in the same place.\nLiteral color values may be translucent, either by providing a fourth channel the the hex-notation, or by using a css color function that includes an alpha level (e.g. rgba()). You should avoid mixing this with the use of the opacity aesthetic to ensure the opacity is predictable.",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Fill and Stroke"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/1_color.html#palettes",
    "href": "syntax/scale/aesthetic/1_color.html#palettes",
    "title": "Fill and Stroke",
    "section": "Palettes",
    "text": "Palettes\nThere are two different types of palettes for fill and stroke — those intended for continuous data and those intended for discrete data. While they both consists of multiple color values, the continuous palettes are meant for interpolation between successive values whereas the discrete palettes are not.\nPalettes are used by giving them as names in the TO clause:\n\nVISUALISE FROM ggsql:penguins\nDRAW point\n    MAPPING bill_dep AS x, body_mass AS y, species AS fill\n    SETTING stroke =&gt; null\nSCALE color TO category10\n\n\n\n\n\nInstead of using a named palette you can create one on the fly using an array of color values:\n\nVISUALISE FROM ggsql:penguins\nDRAW point\n    MAPPING bill_dep AS x, body_mass AS y, flipper_len AS fill\n    SETTING stroke =&gt; null\nSCALE color TO ['antiquewhite', 'firebrick']\n\n\n\n\n\n\nContinuous palettes\n\nSequential\nSequential palettes for numeric data. navia is the default continuous color palette in ggsql.\n\n\n\n\n\n\n\n\n\nName\nGradient\nSource\nDescription\n\n\n\n\nnavia\n\nCrameri\nDefault. Blue-green-cream (alias: sequential)\n\n\nbatlow\n\nCrameri\nBlue-green-yellow-red\n\n\nbatlowk\n\nCrameri\nDark variant of batlow\n\n\nbatloww\n\nCrameri\nLight variant of batlow\n\n\nhawaii\n\nCrameri\nGreen-yellow-orange-magenta\n\n\nlajolla\n\nCrameri\nCream-yellow-orange-brown\n\n\ntokyo\n\nCrameri\nWhite-magenta-dark blue\n\n\nturku\n\nCrameri\nCream-green-dark brown\n\n\nacton\n\nCrameri\nWhite-purple\n\n\nbamako\n\nCrameri\nWhite-brown-dark brown\n\n\nbilbao\n\nCrameri\nWhite-orange-dark brown\n\n\nbuda\n\nCrameri\nWhite-pink-magenta\n\n\ndavos\n\nCrameri\nWhite-blue\n\n\ndevon\n\nCrameri\nWhite-blue-dark blue\n\n\nglasgow\n\nCrameri\nBlue-cream-orange\n\n\ngrayc\n\nCrameri\nWhite-black grayscale\n\n\nimola\n\nCrameri\nBlue-cream-green\n\n\nlapaz\n\nCrameri\nWhite-blue-dark\n\n\nlipari\n\nCrameri\nWhite-orange-dark blue\n\n\nnuuk\n\nCrameri\nWhite-blue-green\n\n\noslo\n\nCrameri\nWhite-blue-black\n\n\nblues\n\nColorBrewer\nLight to dark blue\n\n\ngreens\n\nColorBrewer\nLight to dark green\n\n\noranges\n\nColorBrewer\nLight to dark orange\n\n\nreds\n\nColorBrewer\nLight to dark red\n\n\npurples\n\nColorBrewer\nLight to dark purple\n\n\ngreys\n\nColorBrewer\nLight to dark grey (also grays)\n\n\nylorbr\n\nColorBrewer\nYellow-Orange-Brown\n\n\nylorrd\n\nColorBrewer\nYellow-Orange-Red\n\n\nylgn\n\nColorBrewer\nYellow-Green\n\n\nylgnbu\n\nColorBrewer\nYellow-Green-Blue\n\n\ngnbu\n\nColorBrewer\nGreen-Blue\n\n\nbugn\n\nColorBrewer\nBlue-Green\n\n\nbupu\n\nColorBrewer\nBlue-Purple\n\n\npubu\n\nColorBrewer\nPurple-Blue\n\n\npubugn\n\nColorBrewer\nPurple-Blue-Green\n\n\npurd\n\nColorBrewer\nPurple-Red\n\n\nrdpu\n\nColorBrewer\nRed-Purple\n\n\norrd\n\nColorBrewer\nOrange-Red\n\n\nviridis\n\nMatplotlib\nDark purple through blue and green to yellow\n\n\nplasma\n\nMatplotlib\nDark purple through pink to yellow (higher contrast)\n\n\nmagma\n\nMatplotlib\nBlack through purple and pink to light yellow\n\n\ninferno\n\nMatplotlib\nBlack through red and orange to light yellow\n\n\ncividis\n\nMatplotlib\nDark blue through gray to yellow (colorblind-optimized)\n\n\n\n\n\nDiverging\nDiverging palettes emphasize a critical midpoint with two contrasting hues on either side. Ideal for data with a meaningful center point (e.g., zero, average).\n\n\n\n\n\n\n\n\n\nName\nGradient\nSource\nDescription\n\n\n\n\nvik\n\nCrameri\nBlue-white-red (alias: diverging)\n\n\nberlin\n\nCrameri\nBlue-white-red (different hues)\n\n\nroma\n\nCrameri\nGreen-cream-orange\n\n\nbam\n\nCrameri\nBlue-white-red\n\n\nbroc\n\nCrameri\nBrown-white-green\n\n\ncork\n\nCrameri\nBlue-white-green\n\n\nlisbon\n\nCrameri\nBlue-white-brown\n\n\nmanagua\n\nCrameri\nBlue-white-magenta\n\n\ntofino\n\nCrameri\nBlue-cream-brown\n\n\nvanimo\n\nCrameri\nMagenta-white-green\n\n\nrdbu\n\nColorBrewer\nRed-Blue\n\n\nrdylbu\n\nColorBrewer\nRed-Yellow-Blue\n\n\nrdylgn\n\nColorBrewer\nRed-Yellow-Green\n\n\nspectral\n\nColorBrewer\nSpectral (rainbow-like)\n\n\nbrbg\n\nColorBrewer\nBrown-Blue-Green\n\n\nprgn\n\nColorBrewer\nPurple-Green\n\n\npiyg\n\nColorBrewer\nPink-Yellow-Green\n\n\nrdgy\n\nColorBrewer\nRed-Grey\n\n\npuor\n\nColorBrewer\nPurple-Orange\n\n\n\n\n\nMulti-Sequential\nMulti-sequential palettes have multiple sequential segments, useful for categorical data with ordered subcategories.\n\n\n\n\n\n\n\n\n\nName\nGradient\nSource\nDescription\n\n\n\n\nbukavu\n\nCrameri\nMulti-hue sequential\n\n\nfes\n\nCrameri\nMulti-hue sequential\n\n\noleron\n\nCrameri\nTopographic (land/sea)\n\n\n\n\n\nCyclic\nCyclic palettes wrap around, making them suitable for periodic data like angles, phases, or time of day.\n\n\n\n\n\n\n\n\n\nName\nGradient\nSource\nDescription\n\n\n\n\nromao\n\nCrameri\nCyclic green-orange (alias: cyclic)\n\n\nbamo\n\nCrameri\nCyclic blue-red\n\n\nbroco\n\nCrameri\nCyclic brown-green\n\n\ncorko\n\nCrameri\nCyclic blue-green\n\n\nviko\n\nCrameri\nCyclic blue-red\n\n\n\n\n\n\nDiscrete palettes\n\nQualitative\nQualitative palettes for categorical data where no ordering is implied.\n\n\n\n\n\n\n\n\n\n\nName\nSwatches\nColors\nSource\nDescription\n\n\n\n\nggsql10\n\n10\nggsql\nDefault. Optimized for distinguishability\n\n\ntableau10\n\n10\nTableau\nTableau’s default categorical palette\n\n\ncategory10\n\n10\nD3\nD3’s default categorical palette\n\n\nset1\n\n9\nColorBrewer\nBold, saturated colors\n\n\nset2\n\n8\nColorBrewer\nMuted, softer colors\n\n\nset3\n\n12\nColorBrewer\nPastel-like, lighter colors\n\n\npastel1\n\n9\nColorBrewer\nLight pastel colors\n\n\npastel2\n\n8\nColorBrewer\nSoft pastel colors\n\n\ndark2\n\n8\nColorBrewer\nDark, saturated colors\n\n\npaired\n\n12\nColorBrewer\nLight-dark paired colors\n\n\naccent\n\n8\nColorBrewer\nAccent colors for emphasis\n\n\nkelly22\n\n20\nKelly\nMaximum contrast colors\n\n\n\n\n\n\nReferences\n\nCrameri Scientific Colour Maps\nCrameri, F. (2018). Scientific colour maps. Zenodo. doi:10.5281/zenodo.1243862\nCrameri, F., Shephard, G.E., & Heron, P.J. (2020). The misuse of colour in science communication. Nature Communications, 11, 5444.\n\n\nColorBrewer\nBrewer, C.A. (2002). ColorBrewer: Color Advice for Cartography. colorbrewer2.org\n\n\nMatplotlib\nvan der Walt, S. & Smith, N. (2015). A Better Default Colormap for Matplotlib. SciPy 2015.\n\n\nTableau\nTableau Software. tableau.com\n\n\nD3\nBostock, M. D3.js. d3js.org\n\n\nKelly’s Colors\nKelly, K.L. (1965). Twenty-two colors of maximum contrast. Color Engineering, 3(6), 26-27.\n\n\n\nChoosing a Palette\n\nFor general continuous data\n\nnavia (default) - Good all-purpose choice, perceptually uniform\nviridis - Excellent for print, colorblind-safe, perceptually uniform\nbatlow - Wide perceptual range, good for scientific data\n\n\n\nFor data with a meaningful midpoint\nUse a diverging palette:\n\nvik or berlin - Clear red/blue contrast\nroma - Warm/cool contrast without red/blue\n\n\n\nFor data representing categories with magnitude\nConsider multi-sequential palettes:\n\noleron - Good for topographic data\n\n\n\nFor periodic/cyclic data\nUse a cyclic palette:\n\nromao - Smooth transitions that wrap around\n\n\n\nFor general categorical data\n\nggsql10 (default) - Good all-purpose choice, accessible\ntableau10 - Familiar to many users, well-tested\ncategory10 - Standard web visualization palette\n\n\n\nFor many categories (&gt; 10)\n\nkelly22 - Up to 20 distinguishable colors\nset3 or paired - 12 colors each\n\n\n\nFor subtle/background colors\n\npastel1 or pastel2 - Light, unobtrusive\nset2 - Muted but still distinguishable\n\n\n\nFor bold/emphasis\n\nset1 - Highly saturated, attention-grabbing\ndark2 - Rich, deep colors\n\n\n\nFor paired/related categories\n\npaired - Light-dark pairs show relationships",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Fill and Stroke"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/1_color.html#accessibility",
    "href": "syntax/scale/aesthetic/1_color.html#accessibility",
    "title": "Fill and Stroke",
    "section": "Accessibility",
    "text": "Accessibility\n\nDon’t rely on color alone: Use redundant encoding by combining color with shape, pattern, or direct labels. This ensures information is accessible when color cannot be perceived.\nChoose colorblind-safe palettes: Approximately 8% of men and 0.5% of women have some form of color vision deficiency. Palettes like viridis, cividis, and the Crameri scientific palettes are designed to be distinguishable by colorblind viewers.\nAvoid red-green combinations: Red-green color blindness (deuteranopia/protanopia) is the most common form. Avoid using red and green as the only distinguishing colors between categories.\nEnsure sufficient contrast: Light colors on light backgrounds or dark colors on dark backgrounds can be difficult to perceive. Aim for a contrast ratio of at least 3:1 for graphical elements.\nTest in grayscale: Print or display your visualization in grayscale to verify that information is still distinguishable without color. Palettes like viridis and cividis maintain luminance variation when desaturated.\nLimit the number of colors: Most people can only reliably distinguish 6-8 colors at a glance. For more categories, consider grouping, faceting, or interactive filtering instead of adding more colors.\nUse perceptually uniform palettes: Palettes where equal data differences produce equal perceived color differences prevent visual distortion of your data. The Crameri and matplotlib palettes (viridis, plasma, etc.) are perceptually uniform.\nConsider cultural associations: Colors carry different meanings across cultures (e.g., red can signify danger, luck, or political affiliation). Be mindful of unintended connotations in your audience.\nProvide alternatives: When possible, offer a data table or text description alongside color-encoded visualizations for users who cannot perceive the colors.",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Fill and Stroke"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/1_color.html#footnotes",
    "href": "syntax/scale/aesthetic/1_color.html#footnotes",
    "title": "Fill and Stroke",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nFor a complete overview see the documentation for the csscolorparser crate which is what we use internally.↩︎",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Fill and Stroke"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/size.html",
    "href": "syntax/scale/aesthetic/size.html",
    "title": "Size",
    "section": "",
    "text": "The size aesthetic defines the size of points (of any shape). It is measured as radius in points (1pt = 1/72 inch) of an idealized circle. Size is most often used to create a bubble chart, which is a variant of a scatter plot where a continuous value is mapped to the size of the points.\nsize is scaled by area rather than radius. This means it has an implicit square root transform applied on top of any other transform you may add. This ensures that steps in data value correspond to equal steps in perceived size (which is proportional to area).",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Size"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/size.html#literal-values",
    "href": "syntax/scale/aesthetic/size.html#literal-values",
    "title": "Size",
    "section": "Literal values",
    "text": "Literal values\nSizes are given as bare numbers and measured in points. The following code will e.g. set the radius of points to 3pt (~28pt²):\nDRAW point\n    SETTING size =&gt; 3",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Size"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/size.html#palettes",
    "href": "syntax/scale/aesthetic/size.html#palettes",
    "title": "Size",
    "section": "Palettes",
    "text": "Palettes\nSize can only be used for sequential data and has no named palettes. The default for continuous, binned, and ordinal scales is to use the range from 1pt to 6 pt and interpolate between them. This can be overwritten by providing a manual output range specification\nSCALE size TO [3, 9]",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Size"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/linewidth.html",
    "href": "syntax/scale/aesthetic/linewidth.html",
    "title": "Linewidth",
    "section": "",
    "text": "The linewidth aesthetic sets the width of strokes and lines. It is measured in points (1pt = 1/72 inch). Linewidth can be used to represent continuous data. However, care should be taken because the eye is not good at differentiating the relative thinness of thin lines, and using thick lines will often result in severe overplotting.",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Linewidth"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/linewidth.html#literal-values",
    "href": "syntax/scale/aesthetic/linewidth.html#literal-values",
    "title": "Linewidth",
    "section": "Literal values",
    "text": "Literal values\nLinewidth are given as bare numbers and measured in points. The following code sets the width of the lines to 3pt:\nDRAW line\n    SETTING linewidth =&gt; 3",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Linewidth"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/linewidth.html#palettes",
    "href": "syntax/scale/aesthetic/linewidth.html#palettes",
    "title": "Linewidth",
    "section": "Palettes",
    "text": "Palettes\nLinewidth can only be used for sequential data and has no named palettes. The default for continuous, binned, and ordinal scales is to use the range from 1pt to 6 pt and interpolate between them. This can be overwritten by providing a manual output range specification\nSCALE linewidth TO [3, 9]",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Linewidth"
    ]
  },
  {
    "objectID": "syntax/scale/type/continuous.html",
    "href": "syntax/scale/type/continuous.html",
    "title": "Continuous",
    "section": "",
    "text": "Scales are declared with the SCALE clause. Read the documentation for this clause for a thorough description of its syntax.\nThe continuous scale type maps various continuous data types into a continuous output domain. The most common of these are basic numbers, but also dates in various forms are considered continuous.",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Continuous"
    ]
  },
  {
    "objectID": "syntax/scale/type/continuous.html#input-range",
    "href": "syntax/scale/type/continuous.html#input-range",
    "title": "Continuous",
    "section": "Input range",
    "text": "Input range\nThe input range for continuous scales are defined by their minimum and maximum values. These can be given explicitly or deduced from the mapped data. If FROM is omitted then the range of the mapped data is used. If provided as an array of length 2 then the first element will set the minimum and the second element will set the maximum. If either of these elements are null then that part of the range will be deduced from the data. As an example SCALE x FROM [0, null] will set the minimum part of the range to 0 and the maximum part to the maximal value of the mapped data.\nPositional aesthetics (x and y) will have their range expanded based on the expand setting. If values in the mapped data falls outside of the input domain the values will be changed based on the oob setting.\nThe input range is converted to the type defined by the transform. This means that a time range can both be given as a %H:%M:%S string or as a numeric giving the number of nanoseconds since midnight.\n\nExamples\n\nExplicit setting the full range\n\nVISUALISE bill_len AS x, bill_dep AS y FROM ggsql:penguins\nDRAW point\nSCALE x FROM [40, 50]\n\n\n\n\n\n\n\nAllow one end of the range to be imputed\n\nVISUALISE bill_len AS x, bill_dep AS y FROM ggsql:penguins\nDRAW point\nSCALE x FROM [0, null]",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Continuous"
    ]
  },
  {
    "objectID": "syntax/scale/type/continuous.html#output-range",
    "href": "syntax/scale/type/continuous.html#output-range",
    "title": "Continuous",
    "section": "Output range",
    "text": "Output range\nThe output range can either be given as an array of values or a named palette. For continuous scales the only palettes of relevance are those for color. Values will, after transformation, be mapped onto the range by interpolating between the provided values. For colors the interpolation will happen in oklab space. Colors can be specified either as hex values, CSS color name or a valid CSS color function (e.g. hsl(300, 76%, 72%))\nAll aesthetics have a default output range so it is never required to provide one unless you want to change from the default. The defaults are as follows:\n\nx/y: Ignored (values used directly)\nstroke/fill: The navia palette\nsize/linewidth: [1, 6] (points)\nopacity: [0.1, 1.0] (0 being fully transparent and 1 being fully opaque)\n\nThe remaining aesthetics doesn’t have a meaningful continuous output domain and doesn’t work with continuous scales. Consider using a binned scale for these if necessary.\n\nExamples\n\nChoose a different palette\n\nVISUALISE bill_len AS x, bill_dep AS y, body_mass AS color FROM ggsql:penguins\nDRAW point\nSCALE color TO batlow\n\n\n\n\n\n\n\nDefine a palette manually\n\nVISUALISE bill_len AS x, bill_dep AS y, body_mass AS color FROM ggsql:penguins\nDRAW point\nSCALE color TO ['black', 'red', 'white']",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Continuous"
    ]
  },
  {
    "objectID": "syntax/scale/type/continuous.html#transform",
    "href": "syntax/scale/type/continuous.html#transform",
    "title": "Continuous",
    "section": "Transform",
    "text": "Transform\nThe transform of the scale both defines how the input data is parsed as well as any mathematical transform applied before it is mapped to the output range. The default transform is deduced from a combination of the mapped data and the aesthetic the scale is applied to.\n\nlinear: The default transform unless stated otherwise. Creates a linear mapping between the input and output range.\nlog/log2/ln: Creates a mapping between the logarithm of the input to the output range.\nexp10/exp2/exp: Inverse of the log transforms\nsqrt: Creates a mapping between the square root of the input to the output range.\nsquare: Inverse of sqrt transform\nasinh: Creates a mapping between the inverse hyperbolic sine of the input to the output range. This approaches the natural logarithm but is well defined for negative values as well, which can make it a good choice for transforming values that exhibit logarithmic growth but span positive and negative values.\npseudo_log/pseudo_log2/pseudo_ln: A slightly different transform that exhibit the same characteristics as asinh but where it is possible to choose the base of the logarithm it should approach.\ninteger: Like linear but will convert input to integer by removing the decimal part.\ndate: Default when mapping a DATE column. Like linear but will cast input to date if not already (for strings this assumes the date is formatted as YYYY-MM-DD, for numbers it will be the number of days since 1970-01-01).\ndatetime: Default when mapping a DATETIME column. Like linear but will cast input to datetime if not already (for strings a range of different permutations of the YYYY-MM-DDTHH:MM:SS.fTZ is tried, for number it will be the number of microseconds since 1970-01-01T00:00:00).\ntime: Default when mapping a TIME column. Like linear but will cast input to time if not already (for strings it assumes the time is formatted as HH:MM:SS.f with both the fractional and second part optional, for number it will be the number of nanoseconds since start of measurement).\n\n\nBreaks\nIf not provided explicitly by the user the breaks for the scales will be calculated for you. The transform will be responsible for the algorithm used to find good break values. It will use the breaks setting and the pretty setting and make a best effort at honouring this.\n\nlinear:\n\npretty =&gt; true: Will use Wilkinsons Extended algorithm to attempt to find nice breaks in the given interval close to the number of breaks requested\npretty =&gt; false: Will produce the requested number of evenly spaced breaks within the scale range\n\nlog/log2/ln:\n\npretty =&gt; true: Will use the 1-2-5 pattern and thin down to approximately the requested number of breaks\npretty =&gt; false: Breaks will be exclusively at the power of the base (e.g. 1, 10, 100, 1000 for log10)\n\nexp10/exp2/exp: Same logic as the log breaks but in the inverse direction\nsqrt/square: Like linear but the range is first converted to sqrt space and the breaks are then converted back\nasinh/pseudo_log/pseudo_log2/pseudo_ln: Like log but includes zero and negates the breaks for the negative part\ninteger: Like linear except disallowing breaks at fractional parts\ndate/datetime/time:\n\nbreaks =&gt; &lt;interval&gt;: If breaks are given as an interval (e.g. week, 30 seconds or 5 years) then the breaks will get that spacing aligned at the interval boundary (Jan 1 for years, etc). This ignores the pretty setting\npretty =&gt; true: An appropriate interval is chosen that approximates the requested number of breaks and then used as above\npretty =&gt; false: Linear spacing in integer space as close to the requested number of breaks\n\n\n\n\nThe size aesthetic\nThe size aesthetic requires special attention. To the user, size is given as radius in points (1/72 inch), but internally the provided values are converted to area, and the scale operates on area transformed values. This means that while you provide the output range in radius, the scaling is proportional to the area, even when using the default linear transform. While this seems somewhat complicated we have chosen this approach to satisfy two opposing needs:\n\nHumans are better at understanding a size when provided as radius/diameter\nWhen making comparison between shape sizes we should compare area\n\nIf you wish to scale by the radius (not advised) you should do so using the square transform (SCALE size VIA square)\n\n\nExamples\n\nAutomatic use of date transform for x axis\n\nVISUALISE Date AS x, Temp AS y FROM ggsql:airquality\nDRAW line\n\n\n\n\n\n\n\nApplying a log transform to the y axis\n\nVISUALISE Date AS x, Temp AS y FROM ggsql:airquality\nDRAW line\nSCALE y VIA log\n\n\n\n\n\n\n\nSetting breaks to exactly dividing the input range\n\nVISUALISE Date AS x, Temp AS y FROM ggsql:airquality\nDRAW line\nSCALE y\n    SETTING breaks =&gt; 5, pretty =&gt; false\n\n\n\n\n\n\n\nUsing an interval size for temporal breaks\n\nVISUALISE Date AS x, Temp AS y FROM ggsql:airquality\nDRAW line\nSCALE x\n    SETTING breaks =&gt; '2 months'",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Continuous"
    ]
  },
  {
    "objectID": "syntax/scale/type/continuous.html#settings",
    "href": "syntax/scale/type/continuous.html#settings",
    "title": "Continuous",
    "section": "Settings",
    "text": "Settings\nThe following settings are recognised by continuous scales:\n\nexpand (only for x/y): Either a scalar number or 2-length array of numbers. Sets the expansion of the scale to either side of the range. If a scalar it gives the multiplicative expansion. If an array the first element is a multiplication factor and the second element is an additive constant. Defaults to 0.05 (5 %). Expansion is only applied to values that are not explicitly given by the user, i.e. if setting the range as SCALE x FROM [0, null] expansion will only be applied to the upper range.\noob: How should values outside of the scale input range be treated. One of 'keep' (keep the values as-is), 'censor' (set to null), or 'squish' (set to the nearest values within the range). Default for x/y is 'keep', for the remaining it is 'censor'.\nbreaks: Either a scalar as described in the section on breaks, or an array of values to place breaks at. Defaults to 5.\npretty: A boolean indicating which algorithm to use for automatic calculation of breaks as described in the section on breaks. Defaults to true.\nreverse: A boolean indicating whether the scale direction should be reversed. Defaults to false.\n\n\nExamples\n\nChange expansion of x axis to add a fixed value\n\nVISUALISE bill_len AS x, bill_dep AS y FROM ggsql:penguins\nDRAW point\nSCALE x \n    SETTING expand =&gt; [0.0, 10]\n\n\n\n\n\n\n\nSquish all y values to show them in the margin of the plot\n\nVISUALISE bill_len AS x, bill_dep AS y FROM ggsql:penguins\nDRAW point\nSCALE y FROM [15, 20]\n    SETTING oob =&gt; 'squish'\n\n\n\n\n\n\n\nSet breaks explicitly\n\nVISUALISE bill_len AS x, bill_dep AS y FROM ggsql:penguins\nDRAW point\nSCALE x \n    SETTING breaks =&gt; [37, 42, 55]\n\n\n\n\n\n\n\nReverse the x axis\n\nVISUALISE bill_len AS x, bill_dep AS y FROM ggsql:penguins\nDRAW point\nSCALE x \n    SETTING reverse =&gt; true",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Continuous"
    ]
  },
  {
    "objectID": "syntax/scale/type/continuous.html#renaming",
    "href": "syntax/scale/type/continuous.html#renaming",
    "title": "Continuous",
    "section": "Renaming",
    "text": "Renaming\nBreaks are generally named by their value. However, you may wish to rename one, several, or all of these. The RENAMING clause allows you to do that both by directly renaming a specific break or by providing a formatting function.\n\nDirect renaming\nWhen you provide a break value on the left and a break exist at that value then it will take on the label specified on the right. For examples adding RENAMING 0 =&gt; 'Nil' will ensure that if there is a break at 0 it will appear as “Nil” on the legend/axis\n\n\nLabel formatting\nBesides direct renaming you can also provide a formatting string if you want the same to happen to all labels, e.g. add a prefix or suffix. The syntax for this is RENAMING * =&gt; '... {} ...'. The current label will be inserted into the {} to produce the new label. Besides simply inserting the break value into the string, we can also provide a formatter. Of special interest to continuous scales are the :time and :num formatters which lets you control how temporal and numeric values are presented. You can read more about these formatters in the break formatting section of the SCALE documentation\nYou can combine formatting with direct renaming in which case the direct renaming has priority over the formatting.\n\n\nExamples\n\nRenaming a single value\n\nVISUALISE bill_len AS x, bill_dep AS y FROM ggsql:penguins\nDRAW point\nSCALE x \n    RENAMING 50 =&gt; 'Fifty'\n\n\n\n\n\n\n\nAdding suffix to break labels\n\nVISUALISE bill_len AS x, bill_dep AS y FROM ggsql:penguins\nDRAW point\nSCALE x \n    RENAMING * =&gt; '{} mm'\n\n\n\n\n\n\n\nUsing a formatter to control temporal formats\n\nVISUALISE Date AS x, Temp AS y FROM ggsql:airquality\nDRAW line\nSCALE x\n    RENAMING * =&gt; '{:time %B}'\n\n\n\n\n\n\n\nUsing a formatter to control number formats\n\nVISUALISE bill_len AS x, bill_dep AS y FROM ggsql:penguins\nDRAW point\nSCALE x\n    RENAMING * =&gt; '{:num %.3e}'",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Continuous"
    ]
  },
  {
    "objectID": "syntax/scale/type/ordinal.html",
    "href": "syntax/scale/type/ordinal.html",
    "title": "Ordinal",
    "section": "",
    "text": "Scales are declared with the SCALE clause. Read the documentation for this clause for a thorough description of its syntax.\nThe ordinal scale type maps ordered discrete data types into a discrete output domain. It can be used to apply sequential palettes to discrete data to reflect their ordered nature. In contrast to discrete scales values from palettes are interpolated across the palette rather than being picked directly if possible.\nThe ordinal scale is never chosen automatically so it must be selected explicitly if needed using SCALE ORDINAL ...",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Ordinal"
    ]
  },
  {
    "objectID": "syntax/scale/type/ordinal.html#input-range",
    "href": "syntax/scale/type/ordinal.html#input-range",
    "title": "Ordinal",
    "section": "Input range",
    "text": "Input range\nThe input range for ordinal scales consists of all the unique values that the scale understand. Their ordering in the input range will determine their internal ordering. Values in the data that do not exist in the input range will be set to null.\n\nExamples\n\nUse input range to define an ordering\n\nSELECT *, \nCASE \n    WHEN Wind &lt;= 3 THEN 'Light Air'\n    WHEN Wind &lt;= 7 THEN 'Light Breeze'\n    WHEN Wind &lt;= 12 THEN 'Gentle Breeze'\n    WHEN Wind &lt;= 18 THEN 'Moderate Breeze'\n    WHEN Wind &lt;= 24 THEN 'Fresh Breeze'\n    ELSE 'Hurricane'\nEND AS Wind_Category\nFROM ggsql:airquality\nVISUALISE Month AS x, Wind AS y, Wind_Category AS color\nDRAW point\n    SETTING opacity =&gt; 1\nSCALE ORDINAL color \n    FROM [\n        'Light Air', \n        'Light Breeze', \n        'Gentle Breeze',\n        'Moderate Breeze',\n        'Fresh Breeze'\n    ]",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Ordinal"
    ]
  },
  {
    "objectID": "syntax/scale/type/ordinal.html#output-range",
    "href": "syntax/scale/type/ordinal.html#output-range",
    "title": "Ordinal",
    "section": "Output range",
    "text": "Output range\nThe output range can either be given as an array of values or a named palette. For interpretable aesthetics (color, opacity, size, and linewidth) the value for each value will be interpolated from the output range. For linetype there is a special sequential palette which is used by default. It will construct linetype patterns that gradually increase in ink-density for the number of bins needed (up to 15 bins). For shape the values will be selected directly from the output range. If there are fewer values in the palette than there are in the input range an error is emitted.\nAll aesthetics has a default output range so it is never required to provide one unless you want to change from the default. The defaults are as follows:\n\nx/y: Ignored (values used directly)\nstroke/fill: The navia palette\nsize/linewidth: [1, 6] (points)\nopacity: [0.1, 1.0] (0 being fully transparent and 1 being fully opaque)\nlinetype: The sequential palette\nshape: The shapes palette\n\nWhile it is possible to use a ordinal scale to map ordered discrete data to linetype and shape you should generally refrain from doing this. Even with the sequential linetype palette it is one of the weakest visual mappings only surpassed by shape which doesn’t show an inherent order in its representation at all.\n\nExamples\n\nUse a continuous color palette with discrete\n\nVISUALISE Ozone AS x, Temp AS y FROM ggsql:airquality\nDRAW point\n    MAPPING Month AS color\nSCALE ORDINAL color TO lapaz\n\n\n\n\n\n\n\nUse linetype for sequential data\n\nVISUALISE Day AS x, Temp AS y FROM ggsql:airquality\nDRAW line\n    MAPPING Month AS linetype\nSCALE ORDINAL linetype",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Ordinal"
    ]
  },
  {
    "objectID": "syntax/scale/type/ordinal.html#transform",
    "href": "syntax/scale/type/ordinal.html#transform",
    "title": "Ordinal",
    "section": "Transform",
    "text": "Transform\nThere are two transforms relevant to ordinal scales and they are only used for casting the data. The string transform converts all data mapped to the scale into strings, and the bool transform will cast all mapped data into a booleans. Apart from this, they have no effect.",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Ordinal"
    ]
  },
  {
    "objectID": "syntax/scale/type/ordinal.html#settings",
    "href": "syntax/scale/type/ordinal.html#settings",
    "title": "Ordinal",
    "section": "Settings",
    "text": "Settings\nThere is only one setting relevant for ordinal scales:\n\nreverse: Reverses the order of the scale. Defaults to false\n\n\nExamples\n\nReverse the scale to swap the color mapping\n\nVISUALISE Ozone AS x, Temp AS y FROM ggsql:airquality\nDRAW point\n    MAPPING Month AS color\nSCALE ORDINAL color\n    SETTING reverse =&gt; true",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Ordinal"
    ]
  },
  {
    "objectID": "syntax/scale/type/ordinal.html#renaming",
    "href": "syntax/scale/type/ordinal.html#renaming",
    "title": "Ordinal",
    "section": "Renaming",
    "text": "Renaming\nBreaks are generally named by their value. However, you may wish to rename one, several, or all of these. The RENAMING clause allows you to do that both by directly renaming a specific break or by providing a formatting function.\n\nDirect renaming\nWhen you provide a break value on the left and a break exist at that value then it will take on the label specified on the right. For examples adding RENAMING 6 =&gt; ‘June’ will ensure that a month given as an integer gets the right name.\n\n\nLabel formatting\nBesides direct renaming you can also provide a formatting string if you want the same to happen to all labels, e.g. add a prefix or suffix. The syntax for this is RENAMING * =&gt; '... {} ...'. The current label will be inserted into the {} to produce the new label. Besides simply inserting the break value into the string, we can also provide a formatter. Of special interest to ordinal scales are the :Title, :lower, and :UPPER formatters which lets you control the casing of strings. You can read more about these formatters in the break formatting section of the SCALE documentation\nYou can combine formatting with direct renaming in which case the direct renaming has priority over the formatting.\n\n\nExamples\n\nSelectively rename a label\n\nVISUALISE Ozone AS x, Temp AS y FROM ggsql:airquality\nDRAW point\n    MAPPING Month AS color\nSCALE ORDINAL color\n    RENAMING 6 =&gt; 'June'\n\n\n\n\n\n\n\nUse string interpolation to add a suffix\n\nVISUALISE Ozone AS x, Temp AS y FROM ggsql:airquality\nDRAW point\n    MAPPING Month AS color\nSCALE ORDINAL color\n    RENAMING * =&gt; '{}th month'\n\n\n\n\n\n\n\nUse a formatter to make labels shouty\n\nSELECT *, \nCASE \n    WHEN Wind &lt;= 3 THEN 'Light Air'\n    WHEN Wind &lt;= 7 THEN 'Light Breeze'\n    WHEN Wind &lt;= 12 THEN 'Gentle Breeze'\n    WHEN Wind &lt;= 18 THEN 'Moderate Breeze'\n    WHEN Wind &lt;= 24 THEN 'Fresh Breeze'\n    ELSE 'Hurricane'\nEND AS Wind_Category\nFROM ggsql:airquality\nVISUALISE Month AS x, Wind AS y, Wind_Category AS color\nDRAW point\n    SETTING opacity =&gt; 1\nSCALE ORDINAL color \n    FROM [\n        'Light Air', \n        'Light Breeze', \n        'Gentle Breeze',\n        'Moderate Breeze',\n        'Fresh Breeze'\n    ]\n    RENAMING * =&gt; '{:UPPER}'",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Ordinal"
    ]
  },
  {
    "objectID": "syntax/clause/label.html",
    "href": "syntax/clause/label.html",
    "title": "Define different titles with LABEL",
    "section": "",
    "text": "The LABEL clause is one of the simpler clauses in ggsql an allow you to override the default naming of axes and legends, as well as adding titles to the plot",
    "crumbs": [
      "Home",
      "Main clauses",
      "`LABEL`"
    ]
  },
  {
    "objectID": "syntax/clause/label.html#clause-syntax",
    "href": "syntax/clause/label.html#clause-syntax",
    "title": "Define different titles with LABEL",
    "section": "Clause syntax",
    "text": "Clause syntax\nThe LABEL clause takes one or more labeling settings.\nLABEL &lt;aesthetic/title&gt; =&gt; &lt;string&gt;, ...\nIf an aesthetic is given, then the title will be used for the relevant axis or legend, e.g. x =&gt; 'my x-axis' will label the x axis, whereas fill =&gt; 'Species' will label the legend for fill (if any).\nThere are a few additional labels beside the aesthetics that govern the different titles of the plot and can be given instead of an aesthetic name:\n\ntitle: The main title of the plot\nsubtitle: An additional, often longer and more descriptive, title beneath the main title\ncaption: A string placed below the plot, often used to add additional information about the data source etc.",
    "crumbs": [
      "Home",
      "Main clauses",
      "`LABEL`"
    ]
  },
  {
    "objectID": "syntax/clause/label.html#automatic-labelling-logic",
    "href": "syntax/clause/label.html#automatic-labelling-logic",
    "title": "Define different titles with LABEL",
    "section": "Automatic labelling logic",
    "text": "Automatic labelling logic\nAxes and legends get an automatic label from the mapping. The logic is as follows:\n\nStart from the global mapping and then go through the layer mappings as they appear.\nCollect mappings for each aesthetic in the order they appear\nFor each aesthetic determine the label based on the following priority:\nAn explicitly provided one with LABEL\nThe name of the first appearing column mapping\nThe name of the aesthetic\n\nThis means that constants mapped to an aesthetic doesn’t contribute to the derived label, only data columns, and if all else fails the name of the aesthetic will be used.",
    "crumbs": [
      "Home",
      "Main clauses",
      "`LABEL`"
    ]
  },
  {
    "objectID": "syntax/clause/scale.html",
    "href": "syntax/clause/scale.html",
    "title": "Specify aesthetic scaling with SCALE",
    "section": "",
    "text": "Scales are an important concept in ggsql. While DRAW clauses define what to draw and what data to base the drawing on, scales control how that data is interpreted, understood, and translated. Because of this a proper understanding of the SCALE clause is integral to releasing all the power of ggsql. Still, scales always comes with sensible defaults so unlike DRAW clauses you may not need them for all your visualisations.",
    "crumbs": [
      "Home",
      "Main clauses",
      "`SCALE`"
    ]
  },
  {
    "objectID": "syntax/clause/scale.html#clause-syntax",
    "href": "syntax/clause/scale.html#clause-syntax",
    "title": "Specify aesthetic scaling with SCALE",
    "section": "Clause syntax",
    "text": "Clause syntax\nThe SCALE clause takes a number of subclauses, all of them optional:\nSCALE &lt;type&gt; &lt;aesthetic&gt; FROM &lt;input-range&gt; TO &lt;output-range&gt; VIA &lt;transform&gt;\n    SETTING &lt;parameter&gt; =&gt; &lt;value&gt;, ...\n    RENAMING &lt;break-value&gt; =&gt; &lt;string&gt;, ...\nThe type defines the class of scale to use. It can be one of four different types:\n\nCONTINUOUS to interpret and treat data as continuous\nDISCRETE to interpret and treat data as discrete or categorical\nBINNED to bin continuous data into discrete bins\nORDINAL to interpret discrete data as ordered\nIDENTITY to let data pass through unscaled\n\nRead more about each type at their dedicated documentation. You do not have to specify the type as it is deduced from the transform, input range, or data if left blank.\nYou must specify an aesthetic so that the scale knows which mapping it belongs to. For positional aesthetics you will provide the base name (x or y) even though you are mapping to e.g. xmin. Creating a scale for colour (or color) will create a scale for both fill and stroke colour based on the settings.\n\nFROM\nThe FROM clause defines the input range of the scale, i.e. the values the scale translates from. If not provided, it will be deduced from the data as the range that covers all mapped data. For discrete scales the input range is defined as an array of all known values to the scale. Values from the data not present in the input range will be null’ed by the scale. For continuous and binned scales this is an array with two elements: the lower and upper boundaries of the scale. Either of these can be null in which case that value will be determined by the data (e.g. a range of [0, null] will go from 0 to the maximum value in the data). Identity scales do not have an input range.\n\n\nTO\nThe TO clause defines the output range of the scale, i.e. what the data is translated to. It can either be an array of values or the name of a known palette. Read more under the documentation for the specific scales.\n\n\nVIA\nThe VIA clause defines a transform which is applied to the data before mapping it to the output range. While transforms are often understood as mathematical transforms, in ggsql it also defines casting of input data. E.g. the integer transform cast all input to integer before mapping. Transforms also takes care of creating breaks that are meaningful for the specific transform, e.g. in the case of the log10 transform where breaks are created to fit the power of 10. Different transforms are available to different scale types.\n\n\nSETTING\nThis clause behaves much like the SETTINGS clause in DRAW, in that it allows you to fine-tune specific behavior of the scale. Permissible settings depends on the scale type and are documented there.\n\n\nRENAMING\nThis clause works much like the LABEL clause but works on the break names of the scale. The general syntax is that you provide the name of the break on the left and what it should appear as on the right, e.g 'adelie' =&gt; 'Pygoscelis adeliae'. The clause is understood as a look-up table in the sense that if you provide a renaming for a break that doesn’t appear in the scale then nothing will happen and if a break exist but doesn’t have a renaming defined it will go through unaltered. To suppress the label of a specific break you can rename it to null, e.g. 'adelie' =&gt; null. This will not remove the break, only the label.\n\nBreak formatting\nApart from the direct renaming described above it is also possible to provide a formatting function to be applied to all breaks. The syntax for this is * =&gt; '...' with the content of the string on the right being a string interpolation format. The basic syntax for this is that the break value will be inserted into any place where {} appears. This means that e.g. * =&gt; '{} species' will result in the label “adelie species” for the break “adelie”. Besides simply inserting the value as-is, it is also possible to apply a formatter to the label before insertion by naming a formatter inside the curly braces prefixed with :. Known formatters are:\n\n{:Title} will title-case the value (make the first letter in each work upper case) before insertion, e.g. * =&gt; '{:Title} species' will become “Adelie species” for the “adelie” break.\n{:UPPER} will make the value upper-case, e.g. * =&gt; '{:UPPER} species' will become “ADELIE species” for the “adelie” break.\n{:lower} works much like {:UPPER} but changes the value to lower-case instead.\n{:time ...} will format a date/datetime/time value according to the format defined afterwards. The formatting follows strftime format using the Rust chrono library. You can see an overview of the supported syntax at the chrono docs. The basic usage is * =&gt; '{:time %B %Y} which would format a break at 2025-07-04 as “July 2025”.\n{:num ...} will format a numeric according to the format defined afterwards. The format follows the printf format using the Rust sprintf library. The syntax is %[flags][width][.precision]type with the following meaning:\n\nflags: One or more modifiers:\n\n-: left-justify\n+: Force sign for positive numbers\n: (space) Space before positive numbers\n0: Zero-pad\n#: Alternate form (0x prefix for hex, etc)\n\nwidth: The minimum width of characters to render. Depending on the flags the string will be padded to be at least this width\nprecision: The maximum precision of the number. For %g/%G it is the total number of digits whereas for the rest it is the number of digits to the right of the decimal point\ntype: How to present the number. One of:\n\nd/i: Signed decimal integers\nu: Unsigned decimal integers\nf/F: Decimal floating point\ne/E: Scientific notation\ng/G: Shortest form of e and f\no: Unsigned octal\nx/X: Unsigned hexadecimal",
    "crumbs": [
      "Home",
      "Main clauses",
      "`SCALE`"
    ]
  },
  {
    "objectID": "syntax/layer/line.html",
    "href": "syntax/layer/line.html",
    "title": "Line",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nThe line layer is used to create lineplots. Lineplots always connects records along the x-axis, in contrast to path layers which use the order of data to connect records. Lines are divided due to their grouping, which is the combination of the discrete mapped aesthetics and the columns specified in the layers PARTITION BY.",
    "crumbs": [
      "Home",
      "Layers",
      "Line"
    ]
  },
  {
    "objectID": "syntax/layer/line.html#aesthetics",
    "href": "syntax/layer/line.html#aesthetics",
    "title": "Line",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the line layer.\n\nRequired\n\nx: Position along the x-axis\ny: Position along the y-axis\n\n\n\nOptional\n\ncolour/stroke: The colour of the line\nopacity: The opacity of the line\nlinewidth: The width of the line\nlinetype: The type of line, i.e. the dashing pattern",
    "crumbs": [
      "Home",
      "Layers",
      "Line"
    ]
  },
  {
    "objectID": "syntax/layer/line.html#settings",
    "href": "syntax/layer/line.html#settings",
    "title": "Line",
    "section": "Settings",
    "text": "Settings\nThe line layer has no additional settings",
    "crumbs": [
      "Home",
      "Layers",
      "Line"
    ]
  },
  {
    "objectID": "syntax/layer/line.html#data-transformation",
    "href": "syntax/layer/line.html#data-transformation",
    "title": "Line",
    "section": "Data transformation",
    "text": "Data transformation\nThe line layer does not transform its data but passes it through unchanged",
    "crumbs": [
      "Home",
      "Layers",
      "Line"
    ]
  },
  {
    "objectID": "syntax/layer/line.html#examples",
    "href": "syntax/layer/line.html#examples",
    "title": "Line",
    "section": "Examples",
    "text": "Examples\nStandard lineplot\n\nVISUALISE FROM ggsql:airquality\nDRAW line\n    MAPPING Date AS x, Temp AS y\n\n\n\n\n\nUse PARTITION BY to create multiple lines\n\nVISUALISE FROM ggsql:airquality\nDRAW line\n    MAPPING Day AS x, Temp AS y\n    PARTITION BY Month\n\n\n\n\n\nor split them with an aesthetic\n\nVISUALISE FROM ggsql:airquality\nDRAW line\n    MAPPING Day AS x, Temp AS y, Month AS color",
    "crumbs": [
      "Home",
      "Layers",
      "Line"
    ]
  },
  {
    "objectID": "syntax/layer/polygon.html",
    "href": "syntax/layer/polygon.html",
    "title": "Polygon",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nPolygons can be used to draw arbitrary closed shapes based on an ordered sequence of x,y-coordinates. They are similar to paths, but close the shapes and fill the interior.",
    "crumbs": [
      "Home",
      "Layers",
      "Polygon"
    ]
  },
  {
    "objectID": "syntax/layer/polygon.html#aesthetics",
    "href": "syntax/layer/polygon.html#aesthetics",
    "title": "Polygon",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the polygon layer.\n\nRequired\n\nx Position along the x-axis.\ny Position along the y-axis.\n\n\n\nOptional\n\nstroke The colour of the contour lines.\nfill The colour of the inner area.\ncolour Shorthand for setting stroke and fill simultaneously.\nopacity The opacity of colours.\nlinewidth The width of the contour lines.\nlinetype The dash pattern of the contour line.",
    "crumbs": [
      "Home",
      "Layers",
      "Polygon"
    ]
  },
  {
    "objectID": "syntax/layer/polygon.html#settings",
    "href": "syntax/layer/polygon.html#settings",
    "title": "Polygon",
    "section": "Settings",
    "text": "Settings\nThe polygon layer has no additional settings",
    "crumbs": [
      "Home",
      "Layers",
      "Polygon"
    ]
  },
  {
    "objectID": "syntax/layer/polygon.html#data-transformation",
    "href": "syntax/layer/polygon.html#data-transformation",
    "title": "Polygon",
    "section": "Data transformation",
    "text": "Data transformation\nThe polygon layer does not transform its data but passes it through unchanged",
    "crumbs": [
      "Home",
      "Layers",
      "Polygon"
    ]
  },
  {
    "objectID": "syntax/layer/polygon.html#examples",
    "href": "syntax/layer/polygon.html#examples",
    "title": "Polygon",
    "section": "Examples",
    "text": "Examples\n\n\nCreate example data\nCREATE TABLE df AS\nSELECT * FROM (VALUES\n  (1.0, 1.0, 'A'),\n  (1.0, 3.0, 'A'),\n  (2.0, 1.0, 'A'),\n  (2.0, 3.0, 'B'),\n  (3.0, 1.0, 'B'),\n  (3.0, 3.0, 'B'),\n) AS t(x, y, id)\n\n\n\n\n\n\n\n\nSimple example polygon.\n\nVISUALISE x, y FROM df\n  DRAW polygon\n\n\n\n\n\nGroups of individual polygons can be declared via PARTITION BY.\n\nVISUALISE x, y FROM df\n  DRAW polygon PARTITION BY id\n\n\n\n\n\nInvoking a group through discrete aesthetics works as well.\n\nVISUALISE x, y FROM df\n  DRAW polygon MAPPING id AS colour",
    "crumbs": [
      "Home",
      "Layers",
      "Polygon"
    ]
  },
  {
    "objectID": "syntax/layer/violin.html",
    "href": "syntax/layer/violin.html",
    "title": "Violin",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nViolin plots display the distribution of a single continuous variable for multiple groups. The violins are mirrored kernel density estimates, similar to the density layer, but organised as distinct groups.",
    "crumbs": [
      "Home",
      "Layers",
      "Violin"
    ]
  },
  {
    "objectID": "syntax/layer/violin.html#aesthetics",
    "href": "syntax/layer/violin.html#aesthetics",
    "title": "Violin",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the violin layer.\n\nRequired\n\nx: Position on the x-axis (categorical).\ny: Value on the y-axis for which to compute density.\n\n\n\nOptional\n\nstroke: The colour of the contour lines.\nfill: The colour of the inner area.\ncolour: Shorthand for setting stroke and fill simultaneously.\nopacity: The opacity of the colours.\nlinewidth: The width of the contour lines.\nlinetype The dash pattern of the contour line.",
    "crumbs": [
      "Home",
      "Layers",
      "Violin"
    ]
  },
  {
    "objectID": "syntax/layer/violin.html#settings",
    "href": "syntax/layer/violin.html#settings",
    "title": "Violin",
    "section": "Settings",
    "text": "Settings\n\nbandwidth: A numerical value setting the smoothing bandwidth to use. If absent (default), the bandwidth will be computed using Silverman’s rule of thumb.\nadjust: A numerical value as multiplier for the bandwidth setting, with 1 as default.\nkernel: Determines the smoothing kernel shape. Can be one of the following:\n\n'gaussian' (default)\n'epanechnikov'\n'triangular'\n'rectangular' or 'uniform'\n'biweight' or 'quartic'\n'cosine'",
    "crumbs": [
      "Home",
      "Layers",
      "Violin"
    ]
  },
  {
    "objectID": "syntax/layer/violin.html#data-transformation",
    "href": "syntax/layer/violin.html#data-transformation",
    "title": "Violin",
    "section": "Data transformation",
    "text": "Data transformation\nA violin layer uses the same computation as a density layer. See the density data transformation section for details. The major difference between a violin layer and a density layer is just the matter of display.\n\nProperties\n\nweight: If mapped, it sets the relative contribution of an observation to the density estimate.\n\n\n\nCalculated statistics\n\ndensity: The estimated probability density per point on the grid. The total area of a single density curve adds up to 1.\nintensity: Also termed ‘probability intensity estimation’, it is the precursor of the density variable. Specifically it is the same as the density without normalisation. You can use REMAPPING intensity AS offset if you want to reflect differences in group sizes.\n\n\n\nDefault remappings\n\ndensity AS offset: By default the offsets around a centerline reflect the computed density.",
    "crumbs": [
      "Home",
      "Layers",
      "Violin"
    ]
  },
  {
    "objectID": "syntax/layer/violin.html#examples",
    "href": "syntax/layer/violin.html#examples",
    "title": "Violin",
    "section": "Examples",
    "text": "Examples\nA typical violin plot.\n\nVISUALISE species AS x, bill_dep AS y FROM ggsql:penguins\n  DRAW violin\n\n\n\n\n\nThe adjust setting controls the smoothing.\n\nVISUALISE species AS x, bill_dep AS y FROM ggsql:penguins\n  DRAW violin SETTING adjust =&gt; 0.1\n\n\n\n\n\nTo more clearly indicate differences in group sizes, you can use the intensity computed variable. Note that we have fewer (n=68) Chinstrap penguins than Adelie (n=152) or Gentoo (n=124) penguins.\n\nVISUALISE species AS x, bill_dep AS y FROM ggsql:penguins\n  DRAW violin REMAPPING intensity AS offset\n\n\n\n\n\nYou can combine groups to expand the categories.\n\n\nSELECT *, species || ' ' || island AS groups FROM ggsql:penguins\nVISUALISE groups AS x, bill_dep AS y, island AS fill\n  DRAW violin",
    "crumbs": [
      "Home",
      "Layers",
      "Violin"
    ]
  },
  {
    "objectID": "syntax/layer/density.html",
    "href": "syntax/layer/density.html",
    "title": "Density",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nVisualise the distribution of a single continuous variable by computing a kernel density estimate. It has a similar interpretation as a histogram but smoothing out observations rather than binning them.",
    "crumbs": [
      "Home",
      "Layers",
      "Density"
    ]
  },
  {
    "objectID": "syntax/layer/density.html#aesthetics",
    "href": "syntax/layer/density.html#aesthetics",
    "title": "Density",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the density layer.\n\nRequired\n\nx: Position on the x-axis.\n\n\n\nOptional\n\nstroke: The colour of the contour lines.\nfill: The colour of the inner area.\ncolour: Shorthand for setting stroke and fill simultaneously.\nopacity: The opacity of the colours.\nlinewidth: The width of the contour lines.\nlinetype The dash pattern of the contour line.",
    "crumbs": [
      "Home",
      "Layers",
      "Density"
    ]
  },
  {
    "objectID": "syntax/layer/density.html#settings",
    "href": "syntax/layer/density.html#settings",
    "title": "Density",
    "section": "Settings",
    "text": "Settings\n\nstacking: Determines how multiple groups are displayed. One of the following:\n\n'off': The groups y-values are displayed as-is (default).\n'on': The y-values are stacked per x position, accumulating over groups.\n'fill': Like 'on' but displayed as a fraction of the total per x position.\n\nbandwidth: A numerical value setting the smoothing bandwidth to use. If absent (default), the bandwidth will be computed using Silverman’s rule of thumb.\nadjust: A numerical value as multiplier for the bandwidth setting, with 1 as default.\nkernel: Determines the smoothing kernel shape. Can be one of the following:\n\n'gaussian' (default)\n'epanechnikov'\n'triangular'\n'rectangular' or 'uniform'\n'biweight' or 'quartic'\n'cosine'",
    "crumbs": [
      "Home",
      "Layers",
      "Density"
    ]
  },
  {
    "objectID": "syntax/layer/density.html#data-transformation",
    "href": "syntax/layer/density.html#data-transformation",
    "title": "Density",
    "section": "Data transformation",
    "text": "Data transformation\nThe density layer will compute a 1-dimensional grid using the range of the data. The distances between the grid locations and observations are computed (\\(x - x_i\\)) and serve as input for a kernel function. The contributions of each observation is then averaged across the grid.\n\\[\n\\frac{1}{(\\sum_{i=1}^{n}w_i)h}\\sum_{i=1}^{n}w_iK \\left(\\frac{x - x_i}{h}\\right)\n\\]\nWhere:\n\n\\(K\\) is the kernel function\n\\(h\\) is the bandwidth\n\\(w_i\\) is the weight of observation \\(i\\)\n\nBy default \\(w_i = 1\\), so the procedure simplifies thus:\n\\[\n\\frac{1}{nh}\\sum_{i=1}^{n}K \\left(\\frac{x - x_i}{h}\\right)\n\\]\n\nProperties\n\nweight: If mapped, it sets the relative contribution of an observation \\(w_i\\) to the density estimate.\n\n\n\nCalculated statistics\n\ndensity: The estimated probability density per point on the grid. The total area of a single density curve adds up to 1.\nintensity: Also termed ‘probability intensity estimation’, it is the precursor of the density variable. Specifically it is the same as the density without normalisation, i.e. it omits the \\(\\frac{1}{nh}\\) part of the computation. You can use REMAPPING intensity AS y if you want to reflect differences in group sizes.\n\n\n\nDefault remappings\n\ndensity AS y: By default the density layer will display the computed density along the y-axis.",
    "crumbs": [
      "Home",
      "Layers",
      "Density"
    ]
  },
  {
    "objectID": "syntax/layer/density.html#examples",
    "href": "syntax/layer/density.html#examples",
    "title": "Density",
    "section": "Examples",
    "text": "Examples\nA typical KDE computation with different groups:\n\nVISUALISE bill_dep AS x, species AS colour FROM ggsql:penguins\n  DRAW density SETTING opacity =&gt; 0.8\n\n\n\n\n\nChanging the relative bandwidth through the adjust setting.\n\nVISUALISE bill_dep AS x, species AS colour FROM ggsql:penguins\n  DRAW density SETTING opacity =&gt; 0.8, adjust =&gt; 0.1\n\n\n\n\n\nStacking the different groups instead of overlaying them.\n\nVISUALISE bill_dep AS x, species AS colour FROM ggsql:penguins\n  DRAW density SETTING stacking =&gt; 'on'\n\n\n\n\n\nUsing weighted estimates by mapping a column to the optional weight aesthetic. Note that the difference in output is subtle.\n\nVISUALISE bill_dep AS x, species AS colour FROM ggsql:penguins\n  DRAW density \n    MAPPING body_mass AS weight\n    SETTING opacity =&gt; 0.8\n\n\n\n\n\nIf you want to compare a histogram and a density layer, you can use the intensity computed variable to match the histogram scale.\n\nVISUALISE bill_len AS x FROM ggsql:penguins\n  DRAW histogram SETTING opacity =&gt; 0.5\n  DRAW density\n    REMAPPING intensity AS y\n    SETTING opacity =&gt; 0.5\n\n\n\n\n\nUsing the intensity rather than the density also portrays differences in group sizes better. Note the relative height of the groups.\n\nVISUALISE bill_dep AS x, species AS colour FROM ggsql:penguins\n  DRAW density \n    REMAPPING intensity AS y\n    SETTING opacity =&gt; 0.8",
    "crumbs": [
      "Home",
      "Layers",
      "Density"
    ]
  },
  {
    "objectID": "syntax/layer/point.html",
    "href": "syntax/layer/point.html",
    "title": "Point",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nThe point layer is used to create scatterplots. The scatterplot is most useful for displaying the relationship between two continuous variables. A bubblechart is a scatterplot with a third variable mapped to the size of points.",
    "crumbs": [
      "Home",
      "Layers",
      "Point"
    ]
  },
  {
    "objectID": "syntax/layer/point.html#aesthetics",
    "href": "syntax/layer/point.html#aesthetics",
    "title": "Point",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the point layer.\n\nRequired\n\nx: Position along the x-axis\ny: Position along the y-axis\n\n\n\nOptional\n\nsize: The size of each point\ncolour: The default colour of each point\nstroke: The colour of the stroke around each point (if any). Overrides colour\nfill: The fill colour of each point (if any). Overrides colour\nopacity: The opacity of the point\nshape: The shape used to draw the point",
    "crumbs": [
      "Home",
      "Layers",
      "Point"
    ]
  },
  {
    "objectID": "syntax/layer/point.html#settings",
    "href": "syntax/layer/point.html#settings",
    "title": "Point",
    "section": "Settings",
    "text": "Settings\nThe point layer has no additional settings",
    "crumbs": [
      "Home",
      "Layers",
      "Point"
    ]
  },
  {
    "objectID": "syntax/layer/point.html#data-transformation",
    "href": "syntax/layer/point.html#data-transformation",
    "title": "Point",
    "section": "Data transformation",
    "text": "Data transformation\nThe point layer does not transform its data but passes it through unchanged",
    "crumbs": [
      "Home",
      "Layers",
      "Point"
    ]
  },
  {
    "objectID": "syntax/layer/point.html#examples",
    "href": "syntax/layer/point.html#examples",
    "title": "Point",
    "section": "Examples",
    "text": "Examples\nCreate a classic scatterplot\n\nVISUALISE FROM ggsql:penguins\nDRAW point\n    MAPPING bill_len AS x, bill_dep AS y, species AS fill\n    SETTING size =&gt; 30\n\n\n\n\n\nMap to size to create a bubble chart\n\nVISUALISE FROM ggsql:penguins\nDRAW point\n    MAPPING bill_len AS x, bill_dep AS y, body_mass AS size\n\n\n\n\n\nUse filter to only plot a subset of the data\n\nVISUALISE FROM ggsql:penguins\nDRAW point\n    MAPPING bill_len AS x, bill_dep AS y, species AS fill\n    SETTING size =&gt; 30\n    FILTER sex = 'female'",
    "crumbs": [
      "Home",
      "Layers",
      "Point"
    ]
  },
  {
    "objectID": "syntax/layer/ribbon.html",
    "href": "syntax/layer/ribbon.html",
    "title": "Ribbon",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nThe ribbon layer is used to display extrema over a sorted x-axis. It can be seen as an area chart that is unanchored from zero.",
    "crumbs": [
      "Home",
      "Layers",
      "Ribbon"
    ]
  },
  {
    "objectID": "syntax/layer/ribbon.html#aesthetics",
    "href": "syntax/layer/ribbon.html#aesthetics",
    "title": "Ribbon",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the ribbon layer.\n\nRequired\n\nx: Position along the x-axis\nymin: Lower position along the y-axis.\nymax: Upper position along the y-axis.\n\n\n\nOptional\n\nstroke: The colour of the contour lines.\nfill: The colour of the inner area.\ncolour: Shorthand for setting stroke and fill simultaneously.\nopacity: The opacity of the colours.\nlinewidth: The width of the contour lines.",
    "crumbs": [
      "Home",
      "Layers",
      "Ribbon"
    ]
  },
  {
    "objectID": "syntax/layer/ribbon.html#settings",
    "href": "syntax/layer/ribbon.html#settings",
    "title": "Ribbon",
    "section": "Settings",
    "text": "Settings\nThe ribbon layer has no additional settings.",
    "crumbs": [
      "Home",
      "Layers",
      "Ribbon"
    ]
  },
  {
    "objectID": "syntax/layer/ribbon.html#data-transformation",
    "href": "syntax/layer/ribbon.html#data-transformation",
    "title": "Ribbon",
    "section": "Data transformation",
    "text": "Data transformation\nThe ribbon layer does not transform its data but passes it through unchanged.",
    "crumbs": [
      "Home",
      "Layers",
      "Ribbon"
    ]
  },
  {
    "objectID": "syntax/layer/ribbon.html#examples",
    "href": "syntax/layer/ribbon.html#examples",
    "title": "Ribbon",
    "section": "Examples",
    "text": "Examples\nA ribbon plot with arbitrary values as minima/maxima\n\nVISUALISE FROM ggsql:airquality\n  DRAW ribbon\n    MAPPING Date AS x, Wind AS ymin, Temp AS ymax\n\n\n\n\n\nRibbon plots are great for showing the range of some aggregation.\n\n// Weekly aggregation of temperature\nSELECT \n  WEEKOFYEAR(Date) AS Week, \n  MAX(Temp) AS MaxTemp, \n  MEAN(Temp) AS MeanTemp,\n  MIN(Temp) AS MinTemp \nFROM ggsql:airquality\nGROUP BY WEEKOFYEAR(Date)\n\nVISUALISE Week AS x\n  DRAW ribbon \n    MAPPING MinTemp AS ymin, MaxTemp AS ymax\n    SETTING opacity =&gt; 0.5\n  DRAW line\n    MAPPING MeanTemp AS y",
    "crumbs": [
      "Home",
      "Layers",
      "Ribbon"
    ]
  },
  {
    "objectID": "syntax/index.html",
    "href": "syntax/index.html",
    "title": "Syntax",
    "section": "",
    "text": "ggsql augments the standard SQL syntax with a number of new clauses to describe a visualisation:\n\nVISUALISE initiates the visualisation part of the query\nDRAW adds a new layer to the visualisation\nSCALE specify how an aesthetic should be scaled\nFACET describes how data should be split into small multiples\nPROJECT is used for selecting the coordinate system to use\nLABEL is used to manually add titles to the plot or the various axes and legends",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "syntax/index.html#main-clauses",
    "href": "syntax/index.html#main-clauses",
    "title": "Syntax",
    "section": "",
    "text": "ggsql augments the standard SQL syntax with a number of new clauses to describe a visualisation:\n\nVISUALISE initiates the visualisation part of the query\nDRAW adds a new layer to the visualisation\nSCALE specify how an aesthetic should be scaled\nFACET describes how data should be split into small multiples\nPROJECT is used for selecting the coordinate system to use\nLABEL is used to manually add titles to the plot or the various axes and legends",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "syntax/index.html#layers",
    "href": "syntax/index.html#layers",
    "title": "Syntax",
    "section": "Layers",
    "text": "Layers\nThere are many different layers to choose from when visualising your data. Some are straightforward translations of your data into visual marks such as a point layer, while others perform more or less complicated calculations like e.g. the histogram layer. A layer is selected by providing the layer name after the DRAW clause\n\npoint is used to create a scatterplot layer\nline is used to produce lineplots with the data sorted along the x axis\npath is like line above but does not sort the data but plot it according to its own order\narea is used to display series as an area chart.\nribbon is used to display series extrema.\npolygon is used to display arbitrary shapes as polygons.\nbar creates a bar chart, optionally calculating y from the number of records in each bar\ndensity creates univariate kernel density estimates, showing the distribution of a variable\nviolin displays a rotated kernel density estimate\nhistogram bins the data along the x axis and produces a bar for each bin showing the number of records in it\nboxplot displays continuous variables as 5-number summaries",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "syntax/index.html#scales",
    "href": "syntax/index.html#scales",
    "title": "Syntax",
    "section": "Scales",
    "text": "Scales",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "syntax/index.html#coordinate-systems",
    "href": "syntax/index.html#coordinate-systems",
    "title": "Syntax",
    "section": "Coordinate systems",
    "text": "Coordinate systems",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "syntax/layer/histogram.html",
    "href": "syntax/layer/histogram.html",
    "title": "Histogram",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nVisualise the distribution of a single continuous variable by dividing the x axis into bins and counting the number of observations in each bin. If providing a weight then a weighted histogram is calculated instead.",
    "crumbs": [
      "Home",
      "Layers",
      "Histogram"
    ]
  },
  {
    "objectID": "syntax/layer/histogram.html#aesthetics",
    "href": "syntax/layer/histogram.html#aesthetics",
    "title": "Histogram",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the bar layer.\n\nRequired\n\nx: Position on the x-axis\n\n\n\nOptional\n\ncolour: The default colour of each bar\nstroke: The colour of the stroke around each bar. Overrides colour\nfill: The fill colour of each bar. Overrides colour\nopacity: The opacity of the bar fill\nlinewidth: The width of the stroke\nlinetype: The type of stroke, i.e. the dashing pattern",
    "crumbs": [
      "Home",
      "Layers",
      "Histogram"
    ]
  },
  {
    "objectID": "syntax/layer/histogram.html#settings",
    "href": "syntax/layer/histogram.html#settings",
    "title": "Histogram",
    "section": "Settings",
    "text": "Settings\n\nbins: The number of bins to calculate. Defaults to 30\nbinwidth: The width of each bin. If provided it will override the binwidth calculated from bins\nclosed: Either 'left' or 'right' (default). Determines whether the bin intervals are closed to the left or right side",
    "crumbs": [
      "Home",
      "Layers",
      "Histogram"
    ]
  },
  {
    "objectID": "syntax/layer/histogram.html#data-transformation",
    "href": "syntax/layer/histogram.html#data-transformation",
    "title": "Histogram",
    "section": "Data transformation",
    "text": "Data transformation\nThe histogram layer will bin the records in each group and count them. By default it will map the count to y.\n\nProperties\n\nweight: If mapped, the sum of the weights within each bin is calculated instead of the count in each bin\n\n\n\nCalculated statistics\n\ncount: The count or, if weight have been mapped, sum of weights in each bin.\ndensity: The groupwise density, i.e. the count divided by the sum of count among all bins within each group\n\n\n\nDefault remappings\n\ncount AS y: By default the histogram will show count as the height of the bars",
    "crumbs": [
      "Home",
      "Layers",
      "Histogram"
    ]
  },
  {
    "objectID": "syntax/layer/histogram.html#examples",
    "href": "syntax/layer/histogram.html#examples",
    "title": "Histogram",
    "section": "Examples",
    "text": "Examples\nShow the number of each species in the data\n\nVISUALISE FROM ggsql:penguins\nDRAW histogram\n    MAPPING body_mass AS x\n\n\n\n\n\nSplit the histogram in two by mapping sex to fill\n\nVISUALISE FROM ggsql:penguins\nDRAW histogram\n    MAPPING body_mass AS x, sex AS fill\n\n\n\n\n\nMake the two histograms the same scale by remapping to density\n\nVISUALISE FROM ggsql:penguins\nDRAW histogram\n    MAPPING body_mass AS x, sex AS fill\n    REMAPPING density AS y\n\n\n\n\n\nSpecify an exact binwidth if needed\n\nVISUALISE FROM ggsql:penguins\nDRAW histogram\n    MAPPING body_mass AS x\n    SETTING binwidth =&gt; 100",
    "crumbs": [
      "Home",
      "Layers",
      "Histogram"
    ]
  },
  {
    "objectID": "syntax/layer/bar.html",
    "href": "syntax/layer/bar.html",
    "title": "Bar",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nThe bar layer is used to create bar plots. You can either specify the height of the bars directly or let the layer calculate it either as the count of records within the same group or as a weighted sum of the records.",
    "crumbs": [
      "Home",
      "Layers",
      "Bar"
    ]
  },
  {
    "objectID": "syntax/layer/bar.html#aesthetics",
    "href": "syntax/layer/bar.html#aesthetics",
    "title": "Bar",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the bar layer.\n\nRequired\nThe bar layer has no required aesthetics\n\n\nOptional\n\nx: Position on the x-axis. If missing all records will be shown in the same bar\ny: The height of the plot. If missing, it will be calculated by the layer\ncolour: The default colour of each bar\nstroke: The colour of the stroke around each bar. Overrides colour\nfill: The fill colour of each bar. Overrides colour\nopacity: The opacity of the bar fill\nlinewidth: The width of the stroke\nlinetype: The type of stroke, i.e. the dashing pattern",
    "crumbs": [
      "Home",
      "Layers",
      "Bar"
    ]
  },
  {
    "objectID": "syntax/layer/bar.html#settings",
    "href": "syntax/layer/bar.html#settings",
    "title": "Bar",
    "section": "Settings",
    "text": "Settings\n\nwidth: The width of the bars as a proportion of the available width",
    "crumbs": [
      "Home",
      "Layers",
      "Bar"
    ]
  },
  {
    "objectID": "syntax/layer/bar.html#data-transformation",
    "href": "syntax/layer/bar.html#data-transformation",
    "title": "Bar",
    "section": "Data transformation",
    "text": "Data transformation\nIf y has not been mapped the layer will calculate it for you.\n\nProperties\n\nweight: If mapped, the sum of the weights within each group is calculated instead of the count in each group\n\n\n\nCalculated statistics\n\ncount: The count or, if weight have been mapped, sum of weights in each group.\nproportion: The groupwise proportion, i.e. the count divided by the sum of count within each group\n\n\n\nDefault remappings\n\ncount AS y: By default the barplot will show count as the height of the bars",
    "crumbs": [
      "Home",
      "Layers",
      "Bar"
    ]
  },
  {
    "objectID": "syntax/layer/bar.html#examples",
    "href": "syntax/layer/bar.html#examples",
    "title": "Bar",
    "section": "Examples",
    "text": "Examples\nShow the number of each species in the data\n\nVISUALISE FROM ggsql:penguins\nDRAW bar\n    MAPPING species AS x\n\n\n\n\n\nUse weight to instead show the collective mass of each species\n\nVISUALISE FROM ggsql:penguins\nDRAW bar\n    MAPPING species AS x, body_mass AS weight\n\n\n\n\n\nMap fill to a discrete value to create a stacked bar chart\n\nVISUALISE FROM ggsql:penguins\nDRAW bar\n    MAPPING species AS x, island AS fill\n\n\n\n\n\nMap to y if the dataset already contains the value you want to show\n\nSELECT species, MAX(body_mass) AS max_mass FROM ggsql:penguins\nGROUP BY species\nVISUALISE\nDRAW bar\n    MAPPING species AS x, max_mass AS y\n\n\n\n\n\nUse together with a binned scale as an alternative to the histogram layer\n\nVISUALISE FROM ggsql:penguins\nDRAW bar\n    MAPPING body_mass AS x\nSCALE BINNED x\n    SETTING breaks =&gt; 10",
    "crumbs": [
      "Home",
      "Layers",
      "Bar"
    ]
  },
  {
    "objectID": "syntax/layer/boxplot.html",
    "href": "syntax/layer/boxplot.html",
    "title": "Boxplot",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nBoxplots display a summary of a continuous distribution. In the style of Tukey, it displays the median, two hinges and two whiskers as well as outlying points.",
    "crumbs": [
      "Home",
      "Layers",
      "Boxplot"
    ]
  },
  {
    "objectID": "syntax/layer/boxplot.html#aesthetics",
    "href": "syntax/layer/boxplot.html#aesthetics",
    "title": "Boxplot",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the boxplot layer.\n\nRequired\n\nx: Position on the x-axis\ny: Position on the y-axis\n\n\n\nOptional\n\nstroke: The colour of the box contours, whiskers, median line and outliers.\nfill: The colour of the box interior.\ncolour: Shorthand for setting stroke and fill simultaneously. Note that the median line will have bad visibility if stroke and fill are the same.\nopacity: The opacity of the box interior.\nlinewidth The width of the box outline, whiskers, median line and outlier stroke.\nlinetype The linetype of the box outline, whiskers, median line and outlier stroke.\nsize The absolute size of outlier points.\nshape The shape of outlier points.",
    "crumbs": [
      "Home",
      "Layers",
      "Boxplot"
    ]
  },
  {
    "objectID": "syntax/layer/boxplot.html#settings",
    "href": "syntax/layer/boxplot.html#settings",
    "title": "Boxplot",
    "section": "Settings",
    "text": "Settings\n\noutliers: Whether to display outliers as points. Defaults to true.\ncoef: A number indicating the length of the whiskers as a multiple of the interquartile range (IQR). Defaults to 1.5.\nwidth: Relative width of the boxes. Defaults to 0.9.",
    "crumbs": [
      "Home",
      "Layers",
      "Boxplot"
    ]
  },
  {
    "objectID": "syntax/layer/boxplot.html#data-transformation",
    "href": "syntax/layer/boxplot.html#data-transformation",
    "title": "Boxplot",
    "section": "Data transformation",
    "text": "Data transformation\nPer group, data will be divided into 4 quartiles and summary statistics will be derived from their extremes. Because number of observations per quartile may differ by one, the result of this approach may slightly differ from a pure quantile-based approach. The central line represents the median. The boxes are displayed from the 25th up to the 75th percentiles. The whiskers are calculated from the 25th/75th percentiles +/- the IQR times coef, but no more extreme than the data extrema. Observations are considered outliers when they are more extreme than the whiskers.\n\nCalculated statistics\n\ntype: A string representing the type of metric (upper,lower,q1,q3,median,outlier).\nvalue: The value corresponding to the metric.\n\n\n\nDefault remapping\n\nvalue AS y: By default the values are displayed along the y-axis.\n\n\n\nExamples\nA basic boxplot showing the bill length per species.\n\nVISUALISE FROM ggsql:penguins\nDRAW boxplot\n  MAPPING species AS x, bill_len AS y\n\n\n\n\n\nAdditional groups will dodge the boxplots.\n\nVISUALISE FROM ggsql:penguins\nDRAW boxplot\n  MAPPING \n    species AS x, \n    bill_len AS y,\n    island AS stroke\n\n\n\n\n\nNarrow boxes by shrinking the width parameter.\n\nVISUALISE FROM ggsql:penguins\nDRAW boxplot\n  MAPPING species AS x, bill_len AS y\n  SETTING width =&gt; 0.2\n\n\n\n\n\nConsider more observations as outliers by setting a smaller coef:\n\nVISUALISE FROM ggsql:penguins\nDRAW boxplot\n  MAPPING species AS x, bill_len AS y\n  SETTING coef =&gt; 0.1",
    "crumbs": [
      "Home",
      "Layers",
      "Boxplot"
    ]
  },
  {
    "objectID": "syntax/layer/path.html",
    "href": "syntax/layer/path.html",
    "title": "Path",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nThe path layer is used to create lineplots, but contrary to the line layer the data will not be connected along the x-axis. Instead records are connected in the order they appear in the data. Lines are divided due to their grouping, which is the combination of the discrete mapped aesthetics and the columns specified in the layers PARTITION BY.",
    "crumbs": [
      "Home",
      "Layers",
      "Path"
    ]
  },
  {
    "objectID": "syntax/layer/path.html#aesthetics",
    "href": "syntax/layer/path.html#aesthetics",
    "title": "Path",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the path layer.\n\nRequired\n\nx: Position along the x-axis\ny: Position along the y-axis\n\n\n\nOptional\n\ncolour/stroke: The colour of the path\nopacity: The opacity of the path\nlinewidth: The width of the path\nlinetype: The type of path, i.e. the dashing pattern",
    "crumbs": [
      "Home",
      "Layers",
      "Path"
    ]
  },
  {
    "objectID": "syntax/layer/path.html#settings",
    "href": "syntax/layer/path.html#settings",
    "title": "Path",
    "section": "Settings",
    "text": "Settings\nThe line layer has no additional settings",
    "crumbs": [
      "Home",
      "Layers",
      "Path"
    ]
  },
  {
    "objectID": "syntax/layer/path.html#data-transformation",
    "href": "syntax/layer/path.html#data-transformation",
    "title": "Path",
    "section": "Data transformation",
    "text": "Data transformation\nThe line layer does not transform its data but passes it through unchanged",
    "crumbs": [
      "Home",
      "Layers",
      "Path"
    ]
  },
  {
    "objectID": "syntax/layer/path.html#examples",
    "href": "syntax/layer/path.html#examples",
    "title": "Path",
    "section": "Examples",
    "text": "Examples\n\n\nCreate example data\nCREATE TABLE df AS\nSELECT * FROM (VALUES\n  (1.0, 1.0, 'A'),\n  (2.0, 1.0, 'A'),\n  (1.0, 3.0, 'A'),\n  (3.0, 1.0, 'B'),\n  (2.0, 3.0, 'B'),\n  (3.0, 3.0, 'B'),\n) AS t(x, y, id)\n\n\n\n\n\n\n\n\nSimple example path.\n\nVISUALISE x, y FROM df\n  DRAW path\n\n\n\n\n\nContrary to line drawings, path is not forced to follow the order along the axis.\n\nVISUALISE x, y FROM df\n  DRAW path MAPPING 'Path' AS colour\n  DRAW line MAPPING 'Line' AS colour\n\n\n\n\n\nGroups of individual paths can be declared via PARTITION BY.\n\nVISUALISE x, y FROM df\n  DRAW path PARTITION BY id\n\n\n\n\n\nInvoking a group through discrete aesthetics works as well.\n\nVISUALISE x, y FROM df\n  DRAW path MAPPING id AS colour\n\n\n\n\n\nCompared to polygons, paths don’t close their shapes and fill their interiors.\n\nVISUALISE x, y FROM df\n  DRAW polygon MAPPING 'Polygon' AS stroke\n  DRAW path MAPPING 'Path' AS stroke",
    "crumbs": [
      "Home",
      "Layers",
      "Path"
    ]
  },
  {
    "objectID": "syntax/layer/area.html",
    "href": "syntax/layer/area.html",
    "title": "Area",
    "section": "",
    "text": "Layers are declared with the DRAW clause. Read the documentation for this clause for a thorough description of how to use it.\nThe area layer is used to display absolute amounts over a sorted x-axis. It can be seen as a ribbon layer where the ymin is anchored at zero.",
    "crumbs": [
      "Home",
      "Layers",
      "Area"
    ]
  },
  {
    "objectID": "syntax/layer/area.html#aesthetics",
    "href": "syntax/layer/area.html#aesthetics",
    "title": "Area",
    "section": "Aesthetics",
    "text": "Aesthetics\nThe following aesthetics are recognised by the area layer.\n\nRequired\n\nx: Position along the x-axis.\ny: Position along the y-axis.\n\n\n\nOptional\n\nstroke: The colour of the contour lines.\nfill: The colour of the inner area.\ncolour: Shorthand for setting stroke and fill simultaneously.\nopacity: The opacity of the colours.\nlinewidth: The width of the contour lines.",
    "crumbs": [
      "Home",
      "Layers",
      "Area"
    ]
  },
  {
    "objectID": "syntax/layer/area.html#settings",
    "href": "syntax/layer/area.html#settings",
    "title": "Area",
    "section": "Settings",
    "text": "Settings\n\nstacking: Determines how multiple groups are displayed. One of the following:\n\n'off': The groups y-values are displayed as-is (default).\n'on': The y-values are stacked per x position, accumulating over groups.\n'fill': Like 'on' but displayed as a fraction of the total per x position.",
    "crumbs": [
      "Home",
      "Layers",
      "Area"
    ]
  },
  {
    "objectID": "syntax/layer/area.html#data-transformation",
    "href": "syntax/layer/area.html#data-transformation",
    "title": "Area",
    "section": "Data transformation",
    "text": "Data transformation\nThe area layer does not transform its data but passes it through unchanged.",
    "crumbs": [
      "Home",
      "Layers",
      "Area"
    ]
  },
  {
    "objectID": "syntax/layer/area.html#examples",
    "href": "syntax/layer/area.html#examples",
    "title": "Area",
    "section": "Examples",
    "text": "Examples\nCreate a typical area chart\n\nVISUALISE FROM ggsql:airquality\nDRAW area \n  MAPPING Date AS x, Wind AS y\n\n\n\n\n\nWe can reshape the data to ‘long format’ from our wide format.\n\nCREATE TABLE long_airquality AS\nSELECT * FROM ggsql:airquality\nUNPIVOT(\n  Value FOR Series IN (Temp, Wind)\n) AS u;\n\n\n\n\n\n\n\nWhich means we can display multiple series at once, by mapping the identifier to an aesthetic.\n\nVISUALISE Date AS x, Value AS y FROM long_airquality\n  DRAW area MAPPING Series AS colour\n\n\n\n\n\nWe can stack the series by using stacking =&gt; 'on'. The line serves as a reference for ‘unstacked’ data.\n\nVISUALISE Date AS x, Value AS y, Series AS colour FROM long_airquality\n  DRAW area SETTING stacking =&gt; 'on', opacity =&gt; 0.5\n  DRAW line\n\n\n\n\n\nWhen stacking =&gt; 'fill' we’re plotting stacked proportions. These only make sense if every series is measured in the same absolute unit. (Wind and temperature have different units and the temperature is not absolute.)\n\nVISUALISE Date AS x, Value AS y, Series AS colour FROM long_airquality\n  DRAW area SETTING stacking =&gt; 'fill'",
    "crumbs": [
      "Home",
      "Layers",
      "Area"
    ]
  },
  {
    "objectID": "syntax/clause/draw.html",
    "href": "syntax/clause/draw.html",
    "title": "Create layers with DRAW",
    "section": "",
    "text": "DRAW is perhaps the most important clause in ggsql as it defines a layer in your visualisation. A layer is a single instance of a visual representation of a dataset. A visualisation can contain multiple layers, either showing the same dataset in different ways or showing different data in each. Layers are drawn in the order they are defined, so that layers defined first will be behind layers defined last.",
    "crumbs": [
      "Home",
      "Main clauses",
      "`DRAW`"
    ]
  },
  {
    "objectID": "syntax/clause/draw.html#clause-syntax",
    "href": "syntax/clause/draw.html#clause-syntax",
    "title": "Create layers with DRAW",
    "section": "Clause syntax",
    "text": "Clause syntax\nThe DRAW clause takes a number of subclauses, all of them optional if the VISUALISE clause provides a global mapping and data source.\nDRAW &lt;layer-type&gt;\n    MAPPING &lt;mapping&gt;, ... FROM &lt;data-source&gt;\n    REMAPPING &lt;mapping&gt;, ...\n    SETTING &lt;parameter/aesthetic&gt; =&gt; &lt;value&gt;, ...\n    FILTER &lt;condition&gt;\n    PARTITION BY &lt;column&gt;, ...\n    ORDER BY &lt;column&gt;, ...\nThe only required part is the layer type immediately following the DRAW clause, which specifies the type of layer to draw, e.g. point or histogram. It defines how the remaining settings are interpreted. The main syntax page has a list of all available layer types\n\nMAPPING\nMAPPING &lt;mapping&gt;, ... FROM &lt;data-source&gt;\nThe MAPPINGS clause define how data from the dataset are related to visual aesthetics or statistical properties. Multiple mappings can be provided by separating them with a comma. Mapped aesthetics are always scaled by their respective scale. This means that if you map the value ‘red’ to fill, then fill will not take the color red, but whatever the scale decides should represent the string ‘red’. Layer mappings are merged with the global mapping from the VISUALISE clause with the one in the layer taking precedence. This means that it is not necessary to provide any mappings in the DRAW clause if sufficient global mappings are provided.\nMAPPING may have a FROM clause that defines the source of the data. If this is missing the global data source from VISUALISE is used.\nThe mapping can take one of three forms and all three can be mixed in the same MAPPING clause:\n\n&lt;data&gt; AS &lt;aesthetic/property&gt; (explicit mapping)\n&lt;data&gt; (implicit mapping)\n* (wildcard mapping)\n\ndata can be either:\n\nColumn name: If you provide the name of a column in the layer data (or global data in the absence of layer data) then the values in that column are mapped to the aesthetic or property. If the name of the column is the same as the aesthetic or property you can provide it without the following AS &lt;aesthetic/property&gt; (implicit mapping).\nConstant: If you provide a constant like a string, number, or boolean then this value is repeated for every record in the data and mapped to the given aesthetic or property. When mapping a constant you must use the explicit form since the aesthetic/property cannot be derived.\n\nIf an asterisk is given (wildcard mapping) it indicate that every column in the layer data with a name matching a supported aesthetic or property are implicitly mapped to said aesthetic or property. If the aesthetic or property has been mapped elsewhere then that gains precedence (i.e. if writing MAPPING *, revenue AS y then y will take on the data in the revenue column even if a y column exist in the data)\nAn aesthetic is a visual characteristic of what you are rendering. Different aesthetics are available depending on the layer type since e.g. linetype is not relevant for points and shape are not relevant for lines.\nA property is a value used by the statistical transformation done by the layer, e.g. the weight property in the histogram layer that allows weighted histogram calculation.\n\nMapped aesthetics are always scaled by their respective scale, whereas properties are not (there are no scales for properties).\n\nThe documentation for each layer type provides an overview of the aesthetics and properties available for them.\nA layer may use a data source different than the global data by appending a FROM &lt;data-source&gt; to the mapping. The data source can be either:\n\nTable/CTE: If providing an unquoted identifier it is assumed that the data is available in the backend, either as a CTE defined in the pre-query, or as a proper table in the database.\nFilepath: If a string is provided (single quoted), it is assumed to point to a file that can be read directly by the backend.\n\n\n\nREMAPPING\nREMAPPING &lt;mapping&gt;, ...\nSome layer types like histogram runs the data through a statistical transformation in order to arrive at the data that needs to be displayed (e.g. count per bin). During this, one or more columns are added to the data and you can access these in the REMAPPING clause. Layers that perform statistical transformations always have a default remapping (e.g. count AS y in histogram) so it never required to specify a remapping, but you can do so, either to change the default (e.g. density AS yto access the calculated density instead of count), or to use the calculated property for another aesthetic (e.g. count AS fill to also shade the bars according to their height).\nRemappings have to be explicit since the property name never coincide with an aesthetic. Further, remappings must always map to a visual aesthetic since the statistical properties have already been consumed.\n\n\nSETTING\nSETTING &lt;parameter/aesthetic&gt; =&gt; &lt;value&gt;, ...\nThe SETTING clause can be used for to different things:\n\nSetting parameters: Some layers take additional arguments that control how they behave. Often, but not always, these modify the statistical transformation in some way. An example would be the binwidth parameter in histogram which controls the width of each bin during histogram calculation. This is not a statistical property since it is not related to each record, but to the calculation as a whole.\nSetting aesthetics: If you wish to set a specific aesthetic to a literal value, e.g. ‘red’ (as in the color red) then you can do so in the SETTING clause. Aesthetics that are set will not go through a scale but will use the provided value as-is. You cannot set an aesthetic to a column, only to a scalar literal value.\n\n\n\nFILTER\nFILTER &lt;condition&gt;\nYou may not want to use all data provided from the data source in the layer. You can limit the data to plot with the FILTER clause. The content of condition is used directly in a WHERE clause when querying the backend for the layer data, so whatever type of expression you database backend supports there will work.\n\n\nPARTITION BY\nPARTITION BY &lt;column&gt;, ...\nDuring drawing the records in the layer data are grouped by all the discrete data that has been mapped. This grouping is not relevant to all layer types but critical for some, e.g. line layers where the grouping defines which records are connected with a line.\nOften the implicit grouping from the aesthetic mapping is enough, e.g. mapping a discrete value to colour will create one line per colour, but sometimes you need a grouping not reflected in the aesthetic mapping. In that case you can use the PARTITION BY clause to define data columns used for grouping in addition to the ones from the mapping.\n\n\nORDER BY\nORDER BY &lt;column&gt;, ...\nFor some layers the order of records in the data is important, e.g. the path layer which connect records in the order they are provided. Since databases often doesn’t guarantee a specific order of the data, the ORDER BY clause can be used to enforce such and order. Even for layers where the order doesn’t immediately seem to matter it may have an effect, e.g. an overplottet scatterplot where the records in the end of the data are plottet on top of the one in the start.",
    "crumbs": [
      "Home",
      "Main clauses",
      "`DRAW`"
    ]
  },
  {
    "objectID": "syntax/clause/visualise.html",
    "href": "syntax/clause/visualise.html",
    "title": "Initialise a visualisation with VISUALISE",
    "section": "",
    "text": "The VISUALISE (or VISUALIZE) clause marks the beginning of a ggsql visualisation declaration. As such it demarcates where the regular query ends and the visualisation query starts. Everything that comes before the VISUALISE clause is considered a standard SQL query that is sent to the backend. Any CTEs defined therein will be available to the ggsql query, and if it ends with a SELECT query this will automatically be added as the global data for the plot.",
    "crumbs": [
      "Home",
      "Main clauses",
      "`VISUALISE`"
    ]
  },
  {
    "objectID": "syntax/clause/visualise.html#clause-syntax",
    "href": "syntax/clause/visualise.html#clause-syntax",
    "title": "Initialise a visualisation with VISUALISE",
    "section": "Clause syntax",
    "text": "Clause syntax\nThe VISUALISE clause is quite simple and doesn’t take any additional required parameters. You can, however, use it to define global mappings and a global data source (if the earlier query didn’t end in a SELECT).\nVISUALISE &lt;mapping&gt;, ... FROM &lt;data-source&gt;\nFollowing VISUALISE you can provide a series of global mappings. These will be inherited by the layers created with the DRAW clause but can be overwritten by them. Mappings define how data from the dataset are related to visual aesthetics or statistical properties. Multiple mappings can be provided by separating them with a comma. Mapped aesthetics are always scaled by their respective scale. This means that if you map the value ‘red’ to fill, then fill will not take the color red, but whatever the scale decides should represent the string ‘red’.\nVISUALISE may have a FROM clause that defines the source of the global data. If present it overwrites the terminal SELECT clause in the previous query as the global data. Global data is used by layers that do not specify their own data source with MAPPING ... FROM &lt;data-source&gt;.\nThe mapping can take one of three forms and all three can be mixed:\n\n&lt;data&gt; AS &lt;aesthetic/property&gt; (explicit mapping)\n&lt;data&gt; (implicit mapping)\n* (wildcard mapping)\n\ndata can be either:\n\nColumn name: If you provide the name of a column in the data then the values in that column are mapped to the aesthetic or property. If the name of the column is the same as the aesthetic or property you can provide it without the following AS &lt;aesthetic/property&gt; (implicit mapping).\nConstant: If you provide a constant like a string, number, or boolean then this value is repeated for every record in the data and mapped to the given aesthetic or property. When mapping a constant you must use the explicit form since the aesthetic/property cannot be derived.\n\nIf an asterisk is given (wildcard mapping) it indicate that every column in the layer data with a name matching a supported aesthetic or property are implicitly mapped to said aesthetic or property. If the aesthetic or property has been mapped elsewhere then that gains precedence (i.e. if writing VISUALISE *, revenue AS y then y will take on the data in the revenue column even if a y column exist in the data)\nAn aesthetic is a visual characteristic of what you are rendering. Different aesthetics are available depending on the layer type since e.g. linetype is not relevant for points and shape are not relevant for lines.\nA property is a value used by the statistical transformation done by the layer, e.g. the weight property in the histogram layer that allows weighted histogram calculation.\n\nMapped aesthetics are always scaled by their respective scale, whereas properties are not (there are no scales for properties).\n\nLayers only inherit the aesthetics and properties they support from the global mapping. The documentation for each layer type provides an overview of the aesthetics and properties available for them.\nWhen specifying a global data source with FROM &lt;data-source&gt; the data-source can take one of two different forms:\n\nTable/CTE: If providing an unquoted identifier it is assumed that the data is available in the backend, either as a CTE defined in the pre-query, or as a proper table in the database.\nFilepath: If a string is provided (single quoted), it is assumed to point to a file that can be read directly by the backend.",
    "crumbs": [
      "Home",
      "Main clauses",
      "`VISUALISE`"
    ]
  },
  {
    "objectID": "syntax/scale/type/binned.html",
    "href": "syntax/scale/type/binned.html",
    "title": "Binned",
    "section": "",
    "text": "Scales are declared with the SCALE clause. Read the documentation for this clause for a thorough description of its syntax.\nThe binned scale type maps continuous data types into a discrete output domain. It can either be used to bin continuous data for layers that needs a discrete scale, e.g. the bar layer, or to discretize a continuous output range to make clearer visual separation between the groups. Lastly, while generally not advised, it can also be used to map continuous data to an aesthetic that is otherwise only meaningful for discrete data (e.g. shape).\nThe binned scale is never chosen automatically so it must be selected explicitly if needed using SCALE BINNED ...",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Binned"
    ]
  },
  {
    "objectID": "syntax/scale/type/binned.html#input-range",
    "href": "syntax/scale/type/binned.html#input-range",
    "title": "Binned",
    "section": "Input range",
    "text": "Input range\nThe input range for binned scales are defined by their minimum and maximum values. These can be given explicitly or deduced from the mapped data. If FROM is omitted then the range will be given as the minimum and maximum break values, whether provided directly or calculated. If provided as an array of length 2 then the first element will set the minimum and the second element will set the maximum. If either of these elements are null then that part of the range will be deduced from the data. As an example SCALE BINNED x FROM [0, null] will set the minimum part of the range to 0 and the maximum part to the maximal value of the mapped data. However, if neither input range nor explicit breaks are provided then the input range will be modified so that the calculated bins are even sized and include all data. This means that the range in most cases will expand past the minimum and maximum data values.\nPositional aesthetics (x and y) will have their range expanded based on the expand setting. If values in the mapped data falls outside of the input domain the values will be changed based on the oob setting.\nThe input range is converted to the type defined by the transform. This means that a time range can both be given as a %H:%M:%S string or as a numeric giving the number of nanoseconds since midnight.\nIf your data is discrete in nature but does have ordering, consider using the ordinal scale type.\n\nExamples\n\nNot providing input range will ensure even bin size\n\nVISUALISE body_mass AS x FROM ggsql:penguins\nDRAW bar\nSCALE BINNED x\n\n\n\n\n\n\n\nSetting input range will force boundary of terminal bins\n\nVISUALISE body_mass AS x FROM ggsql:penguins\nDRAW bar\nSCALE BINNED x FROM [2700, 6300]",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Binned"
    ]
  },
  {
    "objectID": "syntax/scale/type/binned.html#output-range",
    "href": "syntax/scale/type/binned.html#output-range",
    "title": "Binned",
    "section": "Output range",
    "text": "Output range\nThe output range can either be given as an array of values or a named palette. For interpretable aesthetics (color, opacity, size, and linewidth) the value for each bin will be interpolated from the output range based on the central value of the bin. For linetype there is a special sequential palette which is used by default. It will construct linetype patterns that gradually increase in ink-density for the number of bins needed (up to 15 bins). For shape the values will be selected directly from the output range. If there are fewer values than there are bins an error is emitted.\nAll aesthetics have a default output range so it is never required to provide one unless you want to change from the default. The defaults are as follows:\n\nx/y: Ignored (values used directly)\nstroke/fill: The navia palette\nsize/linewidth: [1, 6] (points)\nopacity: [0.1, 1.0] (0 being fully transparent and 1 being fully opaque)\nlinetype: The sequential palette\nshape: The shapes palette\n\nWhile it is possible to use a binned scale to map continuous data to linetype and shape you should generally refrain from doing this. Even with the sequential linetype palette it is one of the weakest visual mappings only surpassed by shape which doesn’t show an inherent order in its representation at all.\n\nExamples\n\nSelect a continuous color palette\n\nVISUALISE bill_len AS x, bill_dep AS y, body_mass AS color FROM ggsql:penguins\nDRAW point\nSCALE BINNED color TO viridis",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Binned"
    ]
  },
  {
    "objectID": "syntax/scale/type/binned.html#transform",
    "href": "syntax/scale/type/binned.html#transform",
    "title": "Binned",
    "section": "Transform",
    "text": "Transform\nThe transform of the scale both defines how the input data is parsed as well as any mathematical transform applied before it is mapped to the output range. The default transform is deduced from a combination of the mapped data and the aesthetic the scale is applied to.\n\nlinear: The default transform unless stated otherwise. Creates a linear mapping between the input and output range.\nlog/log2/ln: Creates a mapping between the logarithm of the input to the output range.\nexp10/exp2/exp: Inverse of the log transforms\nsqrt: Creates a mapping between the square root of the input to the output range.\nsquare: Inverse of sqrt transform\nasinh: Creates a mapping between the inverse hyperbolic sine of the input to the output range. This approaches the natural logarithm but is well defined for negative values as well, which can make it a good choice for transforming values that exhibit logarithmic growth but span positive and negative values.\npseudo_log/pseudo_log2/pseudo_ln: A slightly different transform that exhibit the same characteristics as asinh but where it is possible to choose the base of the logarithm it should approach.\ninteger: Like linear but will convert input to integer by removing the decimal part.\ndate: Default when mapping a DATE column. Like linear but will cast input to date if not already (for strings this assumes the date is formatted as YYYY-MM-DD, for numbers it will be the number of days since 1970-01-01).\ndatetime: Default when mapping a DATETIME column. Like linear but will cast input to datetime if not already (for strings a range of different permutations of the YYYY-MM-DDTHH:MM:SS.fTZ is tried, for number it will be the number of microseconds since 1970-01-01T00:00:00).\ntime: Default when mapping a TIME column. Like linear but will cast input to time if not already (for strings it assumes the time is formatted as HH:MM:SS.f with both the fractional and second part optional, for number it will be the number of nanoseconds since start of measurement).\n\n\nBreaks\nIf not provided explicitly by the user the breaks for the scales will be calculated for you. The transform will be responsible for the algorithm used to find good break values. It will use the breaks setting and the pretty setting and make a best effort at honouring this.\nSince breaks are not just presentational as it is with continuous scales the choice of transform and break calculation can impact further processing in the pipeline and change its result.\n\nlinear:\n\npretty =&gt; true: Will use Wilkinsons Extended algorithm to attempt to find nice breaks in the given interval close to the number of breaks requested\npretty =&gt; false: Will produce the requested number of evenly spaced breaks within the scale range\n\nlog/log2/ln:\n\npretty =&gt; true: Will use the 1-2-5 pattern and thin down to approximately the requested number of breaks\npretty =&gt; false: Breaks will be exclusively at the power of the base (e.g. 1, 10, 100, 1000 for log10)\n\nexp10/exp2/exp: Same logic as the log breaks but in the inverse direction\nsqrt/square: Like linear but the range is first converted to sqrt space and the breaks are then converted back\nasinh/pseudo_log/pseudo_log2/pseudo_ln: Like log but includes zero and negates the breaks for the negative part\ninteger: Like linear except disallowing breaks at fractional parts\ndate/datetime/time:\n\nbreaks =&gt; &lt;interval&gt;: If breaks are given as an interval (e.g. week, 30 seconds or 5 years) then the breaks will get that spacing aligned at the interval boundary (Jan 1 for years, etc). This ignores the pretty setting\npretty =&gt; true: An appropriate interval is chosen that approximates the requested number of breaks and then used as above\npretty =&gt; false: Linear spacing in integer space as close to the requested number of breaks\n\n\n\n\nThe size aesthetic\nThe size aesthetic requires special attention. To the user, size is given as radius in points (1/72 inch), but internally the provided values are converted to area, and the scale operates on area transformed values. This means that while you provide the output range in radius, the scaling is proportional to the area, even when using the default linear transform. While this seems somewhat complicated we have chosen this approach to satisfy two opposing needs:\n\nHumans are better at understanding a size when provided as radius/diameter\nWhen making comparison between shape sizes we should compare area\n\nIf you wish to scale by the radius (not advised) you should do so using the square transform (SCALE BINNED size VIA square)\n\n\nExamples\n\nTurn off pretty to get exact bins between range\n\nVISUALISE body_mass AS x FROM ggsql:penguins\nDRAW bar\nSCALE BINNED x\n    SETTING pretty =&gt; false\n\n\n\n\n\n\n\nUse a date transform to bin on months\n\nVISUALISE Date AS x, Temp AS y FROM ggsql:airquality\nDRAW boxplot\nSCALE BINNED x VIA date\n    SETTING breaks =&gt; 'month'",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Binned"
    ]
  },
  {
    "objectID": "syntax/scale/type/binned.html#settings",
    "href": "syntax/scale/type/binned.html#settings",
    "title": "Binned",
    "section": "Settings",
    "text": "Settings\nThe following settings are recognised by binned scales:\n\nexpand (only for x/y): Either a scalar number or 2-length array of numbers. Sets the expansion of the scale to either side of the range. If a scalar it gives the multiplicative expansion. If an array the first element is a multiplication factor and the second element is an additive constant. Defaults to 0.05 (5 %). Expansion is only applied to values that are not explicitly given by the user, i.e. if setting the range as SCALE x FROM [0, null] expansion will only be applied to the upper range.\noob: How should values outside of the scale input range be treated. One of 'censor' (set to null), or 'squish' (set to the nearest bin). Default is 'censor'. When set to 'squish' the terminal bin labels will be removed to reflect that they extend to -Inf and Inf.\nbreaks: Either a scalar as described in the section on breaks, or an array of values to place breaks at. Defaults to 5.\npretty: A boolean indicating which algorithm to use for automatic calculation of breaks as described in the section on breaks. Defaults to true.\nreverse: A boolean indicating whether the scale direction should be reversed. Defaults to false.\nclosed: Either 'left' or 'right'. Determines which bin a value will be part of when it lies on the boundary. Defaults to 'left'\n\n\nExamples\n\nUse oob =&gt; ‘squish’ to add data outside range to terminal bins\n\nVISUALISE body_mass AS x FROM ggsql:penguins\nDRAW bar\nSCALE BINNED x\n    SETTING \n        oob =&gt; 'squish', \n        breaks =&gt; [4000, 4250, 4500, 4750, 5000, 5250, 5500]",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Binned"
    ]
  },
  {
    "objectID": "syntax/scale/type/binned.html#renaming",
    "href": "syntax/scale/type/binned.html#renaming",
    "title": "Binned",
    "section": "Renaming",
    "text": "Renaming\nBreaks are generally named by their value. However, you may wish to rename one, several, or all of these. The RENAMING clause allows you to do that both by directly renaming a specific break or by providing a formatting function.\n\nDirect renaming\nWhen you provide a break value on the left and a break exist at that value then it will take on the label specified on the right. For examples adding RENAMING 0 =&gt; 'Nil' will ensure that if there is a break at 0 it will appear as “Nil” on the legend/axis\n\n\nLabel formatting\nBesides direct renaming you can also provide a formatting string if you want the same to happen to all labels, e.g. add a prefix or suffix. The syntax for this is RENAMING * =&gt; '... {} ...'. The current label will be inserted into the {} to produce the new label. Besides simply inserting the break value into the string, we can also provide a formatter. Of special interest to binned scales are the :time and :num formatters which lets you control how temporal and numeric values are presented. You can read more about these formatters in the break formatting section of the SCALE documentation\nYou can combine formatting with direct renaming in which case the direct renaming has priority over the formatting.\n\n\nLabels in binned legends\nWith some writers the legend for binned scales looks like the standard legend but with the label showing the range of the bin. In these situations the renaming is applied before the range label is being created. For example, if you have a RENAMING 0 =&gt; 'zero', then the final label will become “zero – 10” (assuming the upper end of the bin is 10). There is currently no way to take control over the format of the range label.\nIf oob =&gt; 'squish' then the terminal labels are formatted as e.g. “≥ 10” to reflect the terminal bins are open-ended. It still applies that the renaming is applied before constructing the final label\n\n\nExamples\n\nRename a select break\n\nVISUALISE bill_dep AS x FROM ggsql:penguins\nDRAW bar\nSCALE BINNED x \n    RENAMING 50 =&gt; 'Fifty'\n\n\n\n\n\n\n\nAdding suffix to break labels\n\nVISUALISE bill_dep AS x FROM ggsql:penguins\nDRAW bar\nSCALE BINNED x \n    RENAMING * =&gt; '{} mm'\n\n\n\n\n\n\n\nUsing a formatter to control number formats\n\nVISUALISE bill_dep AS x FROM ggsql:penguins\nDRAW bar\nSCALE BINNED x\n    RENAMING * =&gt; '{:num %.1f}'",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Binned"
    ]
  },
  {
    "objectID": "syntax/scale/type/identity.html",
    "href": "syntax/scale/type/identity.html",
    "title": "Identity",
    "section": "",
    "text": "Scales are declared with the SCALE clause. Read the documentation for this clause for a thorough description of its syntax.\n\nThe identity scale is a special scale that allows the input to flow through unchanged. You can use this if your data already contains values in a format understood by the aesthetic, e.g. a column of color values mapped to fill. It doesn’t take any additional settings.\nSince the identity scale doesn’t do any translation of data it doesn’t create a legend.\n\nExamples\n\nUse data values directly for size\n\nVISUALISE bill_len AS x, bill_dep AS y, flipper_len AS size FROM ggsql:penguins\nDRAW point\nSCALE IDENTITY size\n\n\n\n\n\n\n\nUse color values directly\n\nSELECT * FROM (VALUES\n      ('A', 45, 'forestgreen'),\n      ('B', 72, '#3401e3'),\n      ('C', 38, 'hsl(150deg 30% 60%)')\n  ) AS t(category, value, style)\nVISUALISE category AS x, value AS y, style AS fill\nDRAW bar\nSCALE IDENTITY fill",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Identity"
    ]
  },
  {
    "objectID": "syntax/scale/type/discrete.html",
    "href": "syntax/scale/type/discrete.html",
    "title": "Discrete",
    "section": "",
    "text": "Scales are declared with the SCALE clause. Read the documentation for this clause for a thorough description of its syntax.\nThe discrete scale type maps various categorical data types into a discrete output domain. The two categorical data types in ggsql are strings and booleans with strings being the most common. However, you can force a numeric data type into being discrete by explicitly using a discrete scale (e.g. SCALE DISCRETE x)",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Discrete"
    ]
  },
  {
    "objectID": "syntax/scale/type/discrete.html#input-range",
    "href": "syntax/scale/type/discrete.html#input-range",
    "title": "Discrete",
    "section": "Input range",
    "text": "Input range\nThe input range for discrete scales consists of all the unique values that the scale understands. Their ordering in the input range will determine their ordering in the display, either in the legend or the axis. Values in the data that do not exist in the input range will be set to null.\n\nExamples\n\nSet order of bars using input range\n\nVISUALISE species AS x FROM ggsql:penguins\nDRAW bar\nSCALE x FROM ['Chinstrap', 'Gentoo', 'Adelie']\nSCALE y FROM [0, null]\n\n\n\n\n\n\n\nRemove a category by omitting it\n\nVISUALISE species AS x FROM ggsql:penguins\nDRAW bar\nSCALE x FROM ['Adelie', 'Chinstrap']\nSCALE y FROM [0, null]\n\n\n\n\n\n\n\nExplicitly include null in range to show removed data\n\nVISUALISE island AS x FROM ggsql:penguins\nDRAW bar\nSCALE x FROM ['Torgersen', 'Biscoe', null]\nSCALE y FROM [0, null]",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Discrete"
    ]
  },
  {
    "objectID": "syntax/scale/type/discrete.html#output-range",
    "href": "syntax/scale/type/discrete.html#output-range",
    "title": "Discrete",
    "section": "Output range",
    "text": "Output range\nThe output range can either be given as an array of values or a named palette. For both of these, the requirement is that they contain at least the number of values as is present in the input range. There are discrete palettes for both color, linetype, and shape.\nAll aesthetics has a default output range so it is never required to provide one unless you want to change from the default. The defaults are as follows:\n\nx/y: Ignored (values used directly)\nstroke/fill: The ggsql palette\nlinetype: The default palette\nshape: The shapes palette\n\nThe remaining aesthetics don’t have a meaningful discrete output domain and don’t work with discrete scales. Consider using an ordinal scale for these if necessary.\n\nExamples\n\nChoose a different color palette\n\nVISUALISE bill_len AS x, bill_dep AS y, island AS color FROM ggsql:penguins\nDRAW point\nSCALE color TO tableau\n\n\n\n\n\n\n\nConstruct a manual output range\n\nVISUALISE bill_len AS x, bill_dep AS y, island AS shape FROM ggsql:penguins\nDRAW point\nSCALE shape TO ['star', 'circle', 'diamond']",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Discrete"
    ]
  },
  {
    "objectID": "syntax/scale/type/discrete.html#transform",
    "href": "syntax/scale/type/discrete.html#transform",
    "title": "Discrete",
    "section": "Transform",
    "text": "Transform\nThere are two transforms relevant to discrete scales and they are only used for casting the data. The string transform converts all data mapped to the scale into strings, and the bool transform will cast all mapped data into a booleans. Apart from this, they have no effect.",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Discrete"
    ]
  },
  {
    "objectID": "syntax/scale/type/discrete.html#settings",
    "href": "syntax/scale/type/discrete.html#settings",
    "title": "Discrete",
    "section": "Settings",
    "text": "Settings\nThere is only one setting relevant for discrete scales:\n\nreverse: Reverses the order of the scale. Defaults to false\n\n\nExamples\n\nReverse the color legend\n\nVISUALISE bill_len AS x, bill_dep AS y, species AS color FROM ggsql:penguins\nDRAW point\nSCALE color FROM ['Adelie', 'Chinstrap', 'Gentoo']\n    SETTING reverse =&gt; true",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Discrete"
    ]
  },
  {
    "objectID": "syntax/scale/type/discrete.html#renaming",
    "href": "syntax/scale/type/discrete.html#renaming",
    "title": "Discrete",
    "section": "Renaming",
    "text": "Renaming\nBreaks are generally named by their value. However, you may wish to rename one, several, or all of these. The RENAMING clause allows you to do that both by directly renaming a specific break or by providing a formatting function.\n\nDirect renaming\nWhen you provide a break value on the left and a break exist at that value then it will take on the label specified on the right. For examples adding RENAMING ‘Adelie’ =&gt; ‘Adélie’ will ensure that the species name will get the correct diacrit in the label.\n\n\nLabel formatting\nBesides direct renaming you can also provide a formatting string if you want the same to happen to all labels, e.g. add a prefix or suffix. The syntax for this is RENAMING * =&gt; '... {} ...'. The current label will be inserted into the {} to produce the new label. Besides simply inserting the break value into the string, we can also provide a formatter. Of special interest to discrete scales are the :Title, :lower, and :UPPER formatters which lets you control the casing of strings. You can read more about these formatters in the break formatting section of the SCALE documentation\nYou can combine formatting with direct renaming in which case the direct renaming has priority over the formatting.\n\n\nExamples\n\nRename null\n\nVISUALISE sex AS x FROM ggsql:penguins\nDRAW bar\nSCALE x\n    RENAMING 'null' =&gt; 'missing'\nSCALE y FROM [0, null]\n\n\n\n\n\n\n\nAdd prefix\n\nVISUALISE species AS x FROM ggsql:penguins\nDRAW bar\nSCALE x \n    RENAMING * =&gt; 'Species: {}'\nSCALE y FROM [0, null]\n\n\n\n\n\n\n\nApply formatting\n\nVISUALISE bill_len AS x, bill_dep AS y, sex AS color FROM ggsql:penguins\nDRAW point\nSCALE color\n    RENAMING * =&gt; '{:Title}'",
    "crumbs": [
      "Home",
      "Scales",
      "Types",
      "Discrete"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/linetype.html",
    "href": "syntax/scale/aesthetic/linetype.html",
    "title": "Linetype",
    "section": "",
    "text": "The linetype aesthetic defines the stroke pattern of lines: a succession of “on” and “off” parts of the line to make different stipple patterns. Linetype is most useful for line and path layers as a colorless way to differentiate between categories.\nWhile linetypes are most useful for differentiating between discrete data, ggsql also comes with a sequential palette that gradually increases the amount of ink used for the pattern.",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Linetype"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/linetype.html#literal-values",
    "href": "syntax/scale/aesthetic/linetype.html#literal-values",
    "title": "Linetype",
    "section": "Literal values",
    "text": "Literal values\nLinetypes can be specified in two different ways. A couple of patterns are named and can be referred to as such:\n\n\n\n\n\n\n\n\n\nName\nPattern\nStroke-dasharray\nDescription\n\n\n\n\nsolid\n\n(none)\nContinuous solid line\n\n\ndashed\n\n6 4\nStandard dashed line\n\n\ndotted\n\n1 2\nDotted line\n\n\ndotdash\n\n1 2 6 2\nAlternating dot and dash\n\n\nlongdash\n\n10 4\nLong dashes\n\n\ntwodash\n\n6 2 2 2\nTwo different dash lengths\n\n\n\nYou can e.g. use these names when defining a manual palette for the scale:\nSCALE linetype TO ['dashed', 'dotted', 'twodash']\nYou can alternatively specify a custom pattern using hex strings:\nSCALE linetype TO ['44', '1343', '3c6c9c']\nEach pair of hex digits represents on/off lengths:\n\n'44' = 4 on, 4 off (50% ink, similar to dashed)\n'1343' = 1 on, 3 off, 4 on, 3 off (dot-dash pattern)\n'3c6c9c' = 3 on, 12 off, 6 on, 12 off, 9 on, 12 off\n\nValid hex patterns:\n\nMust have 2, 4, 6, or 8 hex digits\nDigits can be 1-9 or a-f (0 is not allowed)\nDigits represent line lengths as multiples of the linewidth",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Linetype"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/linetype.html#palettes",
    "href": "syntax/scale/aesthetic/linetype.html#palettes",
    "title": "Linetype",
    "section": "Palettes",
    "text": "Palettes\nggsql provides two linetype palettes which are generally enough for every need\nThe categorical palette is the default palette for discrete linetype scales. It consists of the 6 named patterns shown above in the same order. Since it is the only palette for discrete linetypes, there is rarely a need to specify it. The categorical palette is the default palette for discrete linetype scales. It consists of the 6 named patterns shown above in the same order. Since it is the only palette for discrete linetypes there is rarely a need to specify it.\n\nSequential palette\nThe sequential palette is the default for binned and ordinal linetype scales. It consists of up to 15 patterns with increasing amount of “on” and decreasing amount of “off”. This creates a visual progression from sparse (low ink) to solid (100% ink).\n\nExample: 5-Level Sequential\n\n\n\n\n\n\n\n\n\nLevel\nPattern\nInk Density\nDescription\n\n\n\n\n1\n\n~6%\nSparse dots\n\n\n2\n\n~29%\nShort dashes\n\n\n3\n\n~52%\nMedium dashes\n\n\n4\n\n~75%\nLong dashes\n\n\n5\n\n100%\nSolid",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Linetype"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/linetype.html#accessibility",
    "href": "syntax/scale/aesthetic/linetype.html#accessibility",
    "title": "Linetype",
    "section": "Accessibility",
    "text": "Accessibility\n\nLinetypes work well for colorblind viewers\nCombine with color for redundant encoding\nLimit to 4-6 distinct linetypes for readability\nSolid lines are most visible; use for primary data",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Linetype"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/shape.html",
    "href": "syntax/scale/aesthetic/shape.html",
    "title": "Shape",
    "section": "",
    "text": "The shape aesthetic governs how points look. Shape can be used instead of color to differentiate between categories of points (or even better, in concert with color). Shape is only meaningful in relation to discrete data.",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Shape"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/shape.html#literal-values",
    "href": "syntax/scale/aesthetic/shape.html#literal-values",
    "title": "Shape",
    "section": "Literal values",
    "text": "Literal values\nShapes are given by name from the following list of 15 possible shapes\n\n\n\n\n\n\n\n\nName\nShape\nDescription\n\n\n\n\ncircle\n\nCircular point (default)\n\n\nsquare\n\nSquare point\n\n\ndiamond\n\nDiamond/rhombus\n\n\ntriangle-up\n\nUpward-pointing triangle\n\n\ntriangle-down\n\nDownward-pointing triangle\n\n\nstar\n\n5-pointed star\n\n\nsquare-cross\n\nSquare with X cutout\n\n\ncircle-plus\n\nCircle with + cutout\n\n\nsquare-plus\n\nSquare with + cutout\n\n\ncross\n\nX shape\n\n\nplus\n\n+ shape\n\n\nasterisk\n\n6-pointed asterisk\n\n\nbowtie\n\nBowtie/hourglass\n\n\nhline\n\nHorizontal line\n\n\nvline\n\nVertical line\n\n\n\nYou can use these names directly when setting the shape of a point:\nDRAW point\n    SETTING shape =&gt; 'star'",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Shape"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/shape.html#palettes",
    "href": "syntax/scale/aesthetic/shape.html#palettes",
    "title": "Shape",
    "section": "Palettes",
    "text": "Palettes\nggsql provides three built-in shape palettes, which is often all you need.\nPalettes are used by giving them as names in the TO clause:\n\nVISUALISE FROM ggsql:penguins\nDRAW point\n    MAPPING bill_dep AS x, body_mass AS y, species AS shape\n    SETTING linewidth =&gt; 1, size =&gt; 5\nSCALE shape TO open\n\n\n\n\n\nInstead of using a named palette you can create one on the fly using an array of shape names:\n\nVISUALISE FROM ggsql:penguins\nDRAW point\n    MAPPING bill_dep AS x, body_mass AS y, species AS shape\n    SETTING linewidth =&gt; 1, size =&gt; 5\nSCALE shape TO ['star', 'bowtie', 'square-plus']\n\n\n\n\n\n\nDefault Palette (closed)\nThe default palette contains the 9 closed shapes (first nine in the table above). This is the recommended palette for most use cases, as closed shapes are more visually prominent and easier to distinguish at small sizes.\nWhile the closed shapes are most often used filled, you can also turn if fill and only draw the stroke for a lighter look.\n\n\nOpen Palette (open)\nThe open palette contains the last 6 shapes in the table. None of these have a fill. You may use this palette when you want transparent shapes that don’t obscure data.\n\n\nAll Shapes Palette (shapes)\nThis palette combines the two palettes above to provide all the possible shapes. Since not all shapes have a fill you should not map fill to anything if using this palette, and you should also be aware that differentiating 15 different shapes in the same plot will require a lot of mental effort from the viewer.\n\n\nAccessibility considerations\n\nLimit to 6-7 distinct shapes for readability\nCombine with color for redundant encoding\nUse larger point sizes when using complex shapes\nClosed shapes are more visible than open shapes",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Shape"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/0_position.html",
    "href": "syntax/scale/aesthetic/0_position.html",
    "title": "Position",
    "section": "",
    "text": "Position aesthetics (x and y, plus all their variants) relate data to placement in the coordinate system of the plot. All layers need at least one of each positional aesthetic mapped in order to show its data. However, the layer may compute positional aesthetics from the mapping. For example, a bar plot calculates the y aesthetic by counting the number of records in each group.",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Position"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/0_position.html#literal-values",
    "href": "syntax/scale/aesthetic/0_position.html#literal-values",
    "title": "Position",
    "section": "Literal values",
    "text": "Literal values\nScales for position aesthetics never use an output range and always relate to the input range. This is a practical decision by ggsql because different writers may treat the positional aesthetic in different ways. 1\n\n\n\n\n\n\nNote\n\n\n\nThe lack of true literal values in position means that it is currently hard to place data and annotation “in-between” breaks in a discrete position scale.",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Position"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/0_position.html#aesthetic-families",
    "href": "syntax/scale/aesthetic/0_position.html#aesthetic-families",
    "title": "Position",
    "section": "Aesthetic families",
    "text": "Aesthetic families\nPositional aesthetics consist of two families: The x and y family. Each of these consist of their primary aesthetic along with a range of sub aesthetic defined by their suffix:\n\n2\nend\nmin\nmax\n\nWhich version of aesthetic to use depends on the layer, but all aesthetics within a family is scaled by the same scale, which is named after its primary aesthetic. This means that even when rendering a layer that only uses xmin and xmax, you will still scale it by writing SCALE x ... and label it by writing LABEL x =&gt; ...",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Position"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/0_position.html#coordinate-system",
    "href": "syntax/scale/aesthetic/0_position.html#coordinate-system",
    "title": "Position",
    "section": "Coordinate system",
    "text": "Coordinate system\nAnother thing that makes positional aesthetics different from other aesthetic is that they are dependent on a coordinate system which takes position scales and defines how values should be converted to a location on a plane. The default Cartesian coordinate system does what is generally expected: it places points along two perpendicular axes in a 2D plane. Other systems such as polar coordinates may dramatically change the look of a layer, transforming both the straightness of lines and positional relation of data.",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Position"
    ]
  },
  {
    "objectID": "syntax/scale/aesthetic/0_position.html#footnotes",
    "href": "syntax/scale/aesthetic/0_position.html#footnotes",
    "title": "Position",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIn reality one could easily think of positional literal values as either normalized position along the x or y axis, or absolute units of distance from the bottom left corner of the coordinate system.↩︎",
    "crumbs": [
      "Home",
      "Scales",
      "Aesthetics",
      "Position"
    ]
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Examples",
    "section": "",
    "text": "This document demonstrates various ggsql features with runnable examples using CSV files."
  },
  {
    "objectID": "examples.html#basic-visualizations",
    "href": "examples.html#basic-visualizations",
    "title": "Examples",
    "section": "Basic Visualizations",
    "text": "Basic Visualizations\n\nSimple Scatter Plot\n\nSELECT x, y FROM 'data.csv'\nVISUALISE x, y\nDRAW point\n\n\n\n\n\n\nVISUALISE bill_len AS x, bill_dep AS y, species AS color FROM ggsql:penguins\nDRAW point\n\n\n\n\n\n\n\nLine Chart with Date Scale\n\nSELECT sale_date, revenue FROM 'sales.csv'\nWHERE category = 'Electronics'\nVISUALISE sale_date AS x, revenue AS y\nDRAW line\nSCALE x VIA date\nLABEL \n    title =&gt; 'Electronics Revenue Over Time', \n    x =&gt; 'Date', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\nSELECT * FROM ggsql:airquality\nVISUALISE Date AS x\nDRAW line MAPPING Ozone AS y, 'Ozone' AS color\nDRAW line MAPPING Temp AS y, 'Temp' AS color\n\n\n\n\n\n\n\nBar Chart by Category\n\nSELECT category, SUM(revenue) as total\nFROM 'sales.csv'\nGROUP BY category\nVISUALISE category AS x, total AS y, category AS fill\nDRAW bar\nLABEL \n    title =&gt; 'Total Revenue by Category', \n    x =&gt; 'Category', \n    y =&gt; 'Total Revenue ($)'\n\n\n\n\n\n\n\nLine chart with multiple lines with same aesthetics\n\nSELECT * FROM 'sales.csv'\nVISUALISE sale_date AS x, revenue AS y\nDRAW line\n    PARTITION BY category"
  },
  {
    "objectID": "examples.html#statistical-transformations",
    "href": "examples.html#statistical-transformations",
    "title": "Examples",
    "section": "Statistical Transformations",
    "text": "Statistical Transformations\nStatistical transformations automatically compute aggregations for certain geom types.\n\nHistogram\nWhen using DRAW histogram, ggsql automatically bins continuous data and counts occurrences. You only need to specify the x aesthetic:\n\nSELECT revenue FROM 'sales.csv'\nVISUALISE revenue AS x\nDRAW histogram\nLABEL\n    title =&gt; 'Revenue Distribution',\n    x =&gt; 'Revenue ($)',\n    y =&gt; 'Count'\n\n\n\n\n\n\n\nBar with Automatic Count\nWhen using DRAW bar without a y aesthetic, ggsql automatically counts occurrences of each x value:\n\nSELECT category FROM 'sales.csv'\nVISUALISE category AS x\nDRAW bar\nLABEL\n    title =&gt; 'Sales Count by Category',\n    x =&gt; 'Category',\n    y =&gt; 'Count'\n\n\n\n\n\n\n\nBar with Weighted Count\nYou can also specify a weight aesthetic to sum values instead of counting:\n\nSELECT category, revenue FROM 'sales.csv'\nVISUALISE category AS x, revenue AS weight\nDRAW bar\nLABEL\n    title =&gt; 'Total Revenue by Category',\n    x =&gt; 'Category',\n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nHistogram Settings\nControl histogram binning with SETTING options:\nCustom number of bins:\n\nSELECT revenue FROM 'sales.csv'\nVISUALISE revenue AS x\nDRAW histogram \n    SETTING bins =&gt; 10\nLABEL\n    title =&gt; 'Revenue Distribution (10 bins)',\n    x =&gt; 'Revenue ($)',\n    y =&gt; 'Count'\n\n\n\n\n\nExplicit bin width (overrides bins):\n\nSELECT revenue FROM 'sales.csv'\nVISUALISE revenue AS x\nDRAW histogram \n    SETTING binwidth =&gt; 500\nLABEL\n    title =&gt; 'Revenue Distribution (500 bin width)',\n    x =&gt; 'Revenue ($)',\n    y =&gt; 'Count'\n\n\n\n\n\nLeft-closed intervals (default is right-closed (a, b]):\n\nSELECT revenue FROM 'sales.csv'\nVISUALISE revenue AS x\nDRAW histogram \n    SETTING bins =&gt; 8, closed =&gt; 'left'\nLABEL\n    title =&gt; 'Revenue Distribution (left-closed intervals)',\n    x =&gt; 'Revenue ($)',\n    y =&gt; 'Count'\n\n\n\n\n\n\n\nHistogram Remapping\nHistogram computes several statistics: bin, bin_end, count, and density. By default, count is mapped to y. Use REMAPPING to show density (proportion) instead:\n\nSELECT revenue FROM 'sales.csv'\nVISUALISE revenue AS x\nDRAW histogram \n    REMAPPING density AS y\nLABEL\n    title =&gt; 'Revenue Density Distribution',\n    x =&gt; 'Revenue ($)',\n    y =&gt; 'Density'\n\n\n\n\n\n\n\nBar Width Setting\nControl bar width with the width setting (0-1 scale, default 0.9):\n\nSELECT category FROM 'sales.csv'\nVISUALISE category AS x\nDRAW bar \n    SETTING width =&gt; 0.5\nLABEL\n    title =&gt; 'Sales Count (Narrow Bars)',\n    x =&gt; 'Category',\n    y =&gt; 'Count'\n\n\n\n\n\n\n\nBar Remapping\nBar computes count and proportion statistics. By default, count is mapped to y. Use REMAPPING to show proportions instead:\n\nSELECT category FROM 'sales.csv'\nVISUALISE category AS x\nDRAW bar \n    REMAPPING proportion AS y\nLABEL\n    title =&gt; 'Sales Proportion by Category',\n    x =&gt; 'Category',\n    y =&gt; 'Proportion'\n\n\n\n\n\nCombine with weight to show weighted proportions:\n\nSELECT category, revenue FROM 'sales.csv'\nVISUALISE category AS x, revenue AS weight\nDRAW bar \n    REMAPPING proportion AS y\nLABEL\n    title =&gt; 'Revenue Share by Category',\n    x =&gt; 'Category',\n    y =&gt; 'Share of Total Revenue'"
  },
  {
    "objectID": "examples.html#multiple-layers",
    "href": "examples.html#multiple-layers",
    "title": "Examples",
    "section": "Multiple Layers",
    "text": "Multiple Layers\n\nLine with Points\n\nSELECT date, value FROM 'timeseries.csv'\nVISUALISE date AS x, value AS y\nDRAW line \n    SETTING  color =&gt; 'blue'\nDRAW point \n    SETTING size =&gt; 6, color =&gt; 'red'\nSCALE x VIA date\nLABEL \n    title =&gt; 'Time Series with Points', \n    x =&gt; 'Date', \n    y =&gt; 'Value'\n\n\n\n\n\n\n\nColored Lines by Category\n\nSELECT date, value, category FROM 'metrics.csv'\nVISUALISE date AS x, value AS y, category AS color\nDRAW line\nSCALE x VIA date\nLABEL \n    title =&gt; 'Metrics by Category', \n    x =&gt; 'Date', \n    y =&gt; 'Value'"
  },
  {
    "objectID": "examples.html#faceting",
    "href": "examples.html#faceting",
    "title": "Examples",
    "section": "Faceting",
    "text": "Faceting\n\nFacet Wrap by Region\n\nSELECT sale_date, revenue, region FROM 'sales.csv'\nWHERE category = 'Electronics'\nVISUALISE sale_date AS x, revenue AS y\nDRAW line\nSCALE x VIA date\nFACET WRAP region\nLABEL \n    title =&gt; 'Electronics Sales by Region', \n    x =&gt; 'Date', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nFacet Grid\n\nSELECT\n    DATE_TRUNC('month', sale_date) as month,\n    region,\n    category,\n    SUM(revenue) as total_revenue,\n    SUM(quantity) * 100 as total_quantity_scaled\nFROM 'sales.csv'\nGROUP BY DATE_TRUNC('month', sale_date), region, category\nVISUALISE month AS x\nDRAW line \n    MAPPING total_revenue AS y\n    SETTING color =&gt; 'steelblue'\nDRAW point \n    MAPPING total_revenue AS y\n    SETTING size =&gt; 6, color =&gt; 'darkblue'\nDRAW line \n    MAPPING total_quantity_scaled AS y\n    SETTING color =&gt; 'coral'\nDRAW point \n    MAPPING total_quantity_scaled AS y\n    SETTING size =&gt; 6, color =&gt; 'orangered'\nSCALE x VIA date\nFACET region BY category\nLABEL \n    title =&gt; 'Monthly Revenue and Quantity by Region and Category', \n    x =&gt; 'Month', \n    y =&gt; 'Value'"
  },
  {
    "objectID": "examples.html#coordinate-transformations",
    "href": "examples.html#coordinate-transformations",
    "title": "Examples",
    "section": "Coordinate Transformations",
    "text": "Coordinate Transformations\n\nFlipped Coordinates (Horizontal Bar Chart)\n\nSELECT region, SUM(revenue) as total\nFROM 'sales.csv'\nGROUP BY region\nORDER BY total DESC\nVISUALISE region AS x, total AS y, region AS fill\nDRAW bar\nCOORD flip\nLABEL \n    title =&gt; 'Total Revenue by Region', \n    x =&gt; 'Region', \n    y =&gt; 'Total Revenue ($)'\n\n\n\n\n\n\n\nCartesian with Axis Limits\n\nSELECT x, y FROM 'data.csv'\nVISUALISE x, y\nDRAW point \n    SETTING size =&gt; 4, color =&gt; 'blue'\nCOORD cartesian \n    SETTING xlim =&gt; [0, 60], ylim =&gt; [0, 70]\nLABEL \n    title =&gt; 'Scatter Plot with Custom Axis Limits', \n    x =&gt; 'X', \n    y =&gt; 'Y'\n\n\n\n\n\n\n\nPie Chart with Polar Coordinates\n\nSELECT category, SUM(revenue) as total\nFROM 'sales.csv'\nGROUP BY category\nVISUALISE total AS y, category AS fill\nDRAW bar\nCOORD polar\nLABEL \n    title =&gt; 'Revenue Distribution by Category'"
  },
  {
    "objectID": "examples.html#constant-mappings",
    "href": "examples.html#constant-mappings",
    "title": "Examples",
    "section": "Constant Mappings",
    "text": "Constant Mappings\nConstants can be used in both the VISUALISE clause (global) and MAPPING clauses (per-layer) to set fixed aesthetic values.\n\nDifferent Constants Per Layer\nEach layer can have its own constant value, creating a legend showing all values:\n\nWITH monthly AS (\n    SELECT\n        DATE_TRUNC('month', sale_date) as month,\n        category,\n        SUM(revenue) as revenue\n    FROM 'sales.csv'\n    GROUP BY DATE_TRUNC('month', sale_date), category\n)\nVISUALISE month AS x, revenue AS y\nDRAW line \n    MAPPING 'Electronics' AS color FROM monthly \n    FILTER category = 'Electronics'\nDRAW line \n    MAPPING 'Clothing' AS color FROM monthly \n    FILTER category = 'Clothing'\nDRAW line \n    MAPPING 'Furniture' AS color FROM monthly \n    FILTER category = 'Furniture'\nSCALE x VIA date\nLABEL \n    title =&gt; 'Revenue by Category (Constant Colors)', \n    x =&gt; 'Month', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nMixed Constants and Columns\nWhen mixing constant and column mappings for the same aesthetic, the axis/legend label uses the first non-constant column name:\n\nSELECT date, value, category FROM 'metrics.csv'\nVISUALISE date AS x\nDRAW line \n    MAPPING value AS y, category AS color\nDRAW point \n    MAPPING 120 AS y \n    SETTING size =&gt; 3, color =&gt; 'blue'\nSCALE x VIA date\nLABEL \n    title =&gt; 'Metrics with Threshold Line', \n    x =&gt; 'Date'\n\n\n\n\n\n\n\nNumeric Constants\nNumbers work as constants too:\n\nSELECT x, y FROM 'data.csv'\nVISUALISE x, y\nDRAW point \n    SETTING color =&gt; 'blue', size =&gt; 10\nDRAW point \n    SETTING color =&gt; 'red', size =&gt; 5 \n    FILTER y &gt; 50\nLABEL \n    title =&gt; 'Scatter Plot with Constant Sizes'"
  },
  {
    "objectID": "examples.html#layer-filtering",
    "href": "examples.html#layer-filtering",
    "title": "Examples",
    "section": "Layer filtering",
    "text": "Layer filtering\n\nFilter one layer\n\nSELECT date, value FROM 'timeseries.csv'\nVISUALISE date AS x, value AS y\nDRAW line \n    SETTING color =&gt; 'blue'\nDRAW point \n    SETTING color =&gt; 'red', size =&gt; 6\n    FILTER value &lt; 130\nSCALE x VIA date\nLABEL \n    title =&gt; 'Time Series with Points', \n    x =&gt; 'Date', \n    y =&gt; 'Value'"
  },
  {
    "objectID": "examples.html#layer-ordering",
    "href": "examples.html#layer-ordering",
    "title": "Examples",
    "section": "Layer ordering",
    "text": "Layer ordering\n\nORDER BY in a layer\nUse ORDER BY to ensure data is sorted correctly within a layer. This is especially important for line charts where the order of points affects the visual path:\n\nWITH unordered_data AS (\n    SELECT * FROM (VALUES\n        (150.0, '2023-03-01'::DATE),\n        (100.0, '2023-01-01'::DATE),\n        (120.0, '2023-05-01'::DATE),\n        (200.0, '2023-02-01'::DATE),\n        (180.0, '2023-04-01'::DATE)\n    ) AS t(value, date)\n)\nVISUALISE\nDRAW path \n    MAPPING date AS x, value AS y FROM unordered_data \n    ORDER BY date\nDRAW point \n    MAPPING date AS x, value AS y FROM unordered_data \n    SETTING size =&gt; 6, color =&gt; 'red'\nSCALE x VIA date\nLABEL \n    title =&gt; 'Line Chart with ORDER BY', \n    x =&gt; 'Date', \n    y =&gt; 'Value'\n\n\n\n\n\n\n\nCombining FILTER and ORDER BY\nThe ORDER BY clause can be combined with FILTER and other layer options:\n\nSELECT date, value, category FROM 'metrics.csv'\nVISUALISE\nDRAW path \n    MAPPING date AS x, value AS y, category AS color \n    FILTER category != 'Support' \n    ORDER BY value\nDRAW point \n    MAPPING date AS x, value AS y, category AS color \n    SETTING size =&gt; 3\n    FILTER category != 'Support' \nSCALE x VIA date\nLABEL \n    title =&gt; 'Sales and Marketing Metrics (Ordered)', \n    x =&gt; 'Date', \n    y =&gt; 'Value'"
  },
  {
    "objectID": "examples.html#common-table-expressions-ctes",
    "href": "examples.html#common-table-expressions-ctes",
    "title": "Examples",
    "section": "Common Table Expressions (CTEs)",
    "text": "Common Table Expressions (CTEs)\n\nSimple CTE with VISUALISE FROM\n\nWITH monthly_sales AS (\n    SELECT\n        DATE_TRUNC('month', sale_date) as month,\n        SUM(revenue) as total_revenue\n    FROM 'sales.csv'\n    GROUP BY DATE_TRUNC('month', sale_date)\n)\nVISUALISE month AS x, total_revenue AS y FROM monthly_sales\nDRAW line\nDRAW point\nSCALE x VIA date\nLABEL \n    title =&gt; 'Monthly Revenue Trends', \n    x =&gt; 'Month', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nMultiple CTEs\n\nWITH daily_sales AS (\n    SELECT sale_date, region, SUM(revenue) as revenue\n    FROM 'sales.csv'\n    GROUP BY sale_date, region\n),\nregional_totals AS (\n    SELECT region, SUM(revenue) as total\n    FROM daily_sales\n    GROUP BY region\n)\nVISUALISE region AS x, total AS y, region AS fill FROM regional_totals\nDRAW bar\nCOORD flip\nLABEL \n    title =&gt; 'Total Revenue by Region', \n    x =&gt; 'Region', \n    y =&gt; 'Total Revenue ($)'"
  },
  {
    "objectID": "examples.html#layer-specific-data-sources-mapping-from",
    "href": "examples.html#layer-specific-data-sources-mapping-from",
    "title": "Examples",
    "section": "Layer-Specific Data Sources (MAPPING FROM)",
    "text": "Layer-Specific Data Sources (MAPPING FROM)\nLayers can pull data from different sources using MAPPING FROM. This enables overlaying data from different CTEs or tables.\n\nComparing Actuals vs Targets\nEach layer can reference a different CTE using MAPPING ... FROM cte_name:\n\nWITH actuals AS (\n    SELECT\n        DATE_TRUNC('month', sale_date) as month,\n        SUM(revenue) as value\n    FROM 'sales.csv'\n    GROUP BY DATE_TRUNC('month', sale_date)\n),\ntargets AS (\n    SELECT * FROM (VALUES\n        ('2023-01-01'::DATE, 5000.0),\n        ('2023-02-01'::DATE, 5500.0),\n        ('2023-03-01'::DATE, 6000.0),\n        ('2023-04-01'::DATE, 6500.0),\n        ('2023-05-01'::DATE, 7000.0),\n        ('2023-06-01'::DATE, 7500.0),\n        ('2023-07-01'::DATE, 8000.0),\n        ('2023-08-01'::DATE, 8500.0),\n        ('2023-09-01'::DATE, 9000.0),\n        ('2023-10-01'::DATE, 9500.0),\n        ('2023-11-01'::DATE, 10000.0),\n        ('2023-12-01'::DATE, 10500.0)\n    ) AS t(month, value)\n)\nVISUALISE\nDRAW line \n    MAPPING month AS x, value AS y, 'Actual' AS color FROM actuals\nDRAW point \n    MAPPING month AS x, value AS y, 'Actual' AS color FROM actuals \n    SETTING size =&gt; 6\nDRAW line \n    MAPPING month AS x, value AS y, 'Target' AS color FROM targets\nSCALE x VIA date\nLABEL \n    title =&gt; 'Revenue: Actual vs Target', \n    x =&gt; 'Month', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nCTE Chain: Raw → Filtered → Aggregated\nCTEs can reference other CTEs, creating a data transformation pipeline:\n\nWITH raw_data AS (\n    SELECT sale_date, revenue, category, region\n    FROM 'sales.csv'\n),\nelectronics_only AS (\n    SELECT * FROM raw_data\n    WHERE category = 'Electronics'\n),\nmonthly_electronics AS (\n    SELECT\n        DATE_TRUNC('month', sale_date) as month,\n        region,\n        SUM(revenue) as total\n    FROM electronics_only\n    GROUP BY DATE_TRUNC('month', sale_date), region\n)\nVISUALISE month AS x, total AS y, region AS color FROM monthly_electronics\nDRAW line\nDRAW point\nSCALE x VIA date\nLABEL \n    title =&gt; 'Electronics Revenue by Region (CTE Chain)', \n    x =&gt; 'Month', \n    y =&gt; 'Revenue ($)'\n\n\n\n\n\n\n\nLayer FROM with FILTER\nCombine FROM with FILTER to get filtered subsets from a CTE:\n\nWITH all_sales AS (\n    SELECT\n        DATE_TRUNC('month', sale_date) as month,\n        category,\n        SUM(revenue) as revenue\n    FROM 'sales.csv'\n    GROUP BY DATE_TRUNC('month', sale_date), category\n)\nVISUALISE\nDRAW line \n    MAPPING month AS x, revenue AS y, 'All Categories' AS color FROM all_sales\nDRAW line \n    MAPPING month AS x, revenue AS y, 'Electronics' AS color FROM all_sales \n    FILTER category = 'Electronics'\nDRAW line \n    MAPPING month AS x, revenue AS y, 'Clothing' AS color FROM all_sales \n    FILTER category = 'Clothing'\nSCALE x VIA date\nLABEL \n    title =&gt; 'Revenue by Category (Filtered Layers)', \n    x =&gt; 'Month', \n    y =&gt; 'Revenue ($)'"
  },
  {
    "objectID": "examples.html#advanced-examples",
    "href": "examples.html#advanced-examples",
    "title": "Examples",
    "section": "Advanced Examples",
    "text": "Advanced Examples\n\nComplete Regional Sales Analysis\n\nSELECT\n    sale_date,\n    region,\n    SUM(quantity) as total_quantity\nFROM 'sales.csv'\nWHERE sale_date &gt;= '2023-01-01'\nGROUP BY sale_date, region\nORDER BY sale_date\nVISUALISE sale_date AS x, total_quantity AS y, region AS color\nDRAW line\nDRAW point\nSCALE x VIA date\nFACET WRAP region\nLABEL \n    title =&gt; 'Sales Trends by Region', \n    x =&gt; 'Date', \n    y =&gt; 'Total Quantity'\n\n\n\n\n\n\n\nMulti-Category Analysis\n\nSELECT\n    category,\n    region,\n    SUM(revenue) as total_revenue\nFROM 'sales.csv'\nGROUP BY category, region\nVISUALISE category AS x, total_revenue AS y, region AS fill\nDRAW bar\nLABEL \n    title =&gt; 'Revenue by Category and Region', \n    x =&gt; 'Category', \n    y =&gt; 'Revenue ($)'"
  }
]